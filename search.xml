<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS基础整理</title>
    <url>/2020/08/10/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要是总结CSS的基础内容，方便日后查阅。</p>
<a id="more"></a>

<h2 id="导入CSS样式的方式"><a href="#导入CSS样式的方式" class="headerlink" title="导入CSS样式的方式"></a>导入CSS样式的方式</h2><ul>
<li><p><strong>行内样式：</strong>在标签元素中直接添加style属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: black;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内部样式：</strong>在head标签内嵌入style样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    p&#123;</span><br><span class="line">        color: black;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>外部样式：</strong>在head标签内声明外部引用，连接到外部.css文件，有两种引用方式分别为链接式和导入式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--链接式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入式，css2.1新增--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="keyword">@import</span> url(css/style.css);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--style.css文件--&gt;</span></span><br><span class="line">p&#123;</span><br><span class="line">    color: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="ff0000">元素样式加载优先级遵循覆盖原则：自上向下逐一执行，最后执行的样式即为最后展示的样式</font></p>
</li>
</ul>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="1.基本选择器"></a>1.基本选择器</h3><ul>
<li><p><strong>标签选择器：</strong></p>
<p>标签选择器会匹配当前页面所有该标签，并使得它们的样式均相同。</p>
</li>
<li><p><strong>类选择器：</strong></p>
<p> 通过指定标签内部class属性，使得每个标签都有一个自己的class类，然后直接在对应class类声明样式，格式：<strong>.class类名{}</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.class1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#0000ff</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.class2</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#adff2f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"class1"</span>&gt;</span>paragon<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"class2"</span>&gt;</span>paragon<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>id选择器：</strong></p>
<p>通过指定标签内部id属性，然后直接在对应id声明样式，格式：<strong>#id名称{}</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#id1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#0000ff</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#id2</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#adff2f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"id1"</span>&gt;</span>paragon<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"id2"</span>&gt;</span>paragon<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>id选择器和class类选择器区别：</strong></p>
<p>id选择器只可使用一次，全局唯一；class类选择器可以跨标签复用。</p>
</li>
<li><p><strong>基本选择器优先级：</strong></p>
<p><font color="ff0000">id选择器 &gt; class类选择器 &gt; 标签选择器</font></p>
</li>
</ul>
<h3 id="2-层次选择器"><a href="#2-层次选择器" class="headerlink" title="2.层次选择器"></a>2.层次选择器</h3><ul>
<li><p><strong>后代选择器</strong></p>
<p>祖先节点的后继所有子节点均继承祖先样式，格式：<strong>父类标签名 父类后继标签名{}</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*表示body以及其后继所有p标签均使用该样式*/</span></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">  color = #adff2f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子选择器</strong></p>
<p>父节点的直系子节点样式继承父节点样式，格式：<strong>父类标签名&gt;子标签名{}</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*表示body的直系p标签使用该样式*/</span></span><br><span class="line"><span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>相邻兄弟选择器</strong></p>
<p>同级兄弟节点其直接下方节点的样式继承兄弟节点样式（兄弟节点样式不生效），格式：<strong>兄弟节点类属性+下方节点{}</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class+p&#123;</span><br><span class="line">		color: aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--只有p3会显示颜色，p4,p2,p1不会显示颜色--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"class"</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通用选择器</strong></p>
<p> 同级兄弟节点其<font color="ff0000">所有下方节点</font>的样式均继承兄弟节点样式（兄弟节点样式不生效），格式：<strong>兄弟节点类属性~下方节点{}</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class~p&#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--p3,p4均会显示颜色，p2,p1不会显示颜色--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"class"</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-结构伪类选择器"><a href="#3-结构伪类选择器" class="headerlink" title="3.结构伪类选择器"></a>3.结构伪类选择器</h3><p>结构伪类选择器详解: <a href="https://blog.csdn.net/ixygj197875/article/details/79038041" target="_blank" rel="noopener">https://blog.csdn.net/ixygj197875/article/details/79038041</a> </p>
<h3 id="4-属性选择器"><a href="#4-属性选择器" class="headerlink" title="4.属性选择器"></a>4.属性选择器</h3><p> 通过标签名下指定的属性名选择样式，格式：<strong>标签名[属性名=”属性值”]{}</strong>，其中：</p>
<ul>
<li>=表示严格匹配，严格匹配当前属性值对应的标签元素。</li>
<li>*=表示贪婪匹配，匹配当前所有含有该属性的所有标签元素。</li>
<li>^=表示起始匹配，匹配当前开头含有该属性的所有标签元素。</li>
<li>$=表示末尾匹配，匹配当前末尾含有该属性的所有标签元素。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/*p2会显示颜色，p1,p3不会显示颜色*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-attr">[class=<span class="string">"class"</span>]</span>&#123;</span></span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="comment">/*p1,p2会显示颜色，p3不会显示颜色*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-attr">[class*=<span class="string">"class"</span>]</span>&#123;</span></span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="comment">/*a1,a2会显示颜色，a3不会显示颜色*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">"1d"</span>]</span>&#123;</span></span><br><span class="line">  color: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="comment">/*a2会显示颜色，a1,a3不会显示颜色*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">"com"</span>]</span>&#123;</span></span><br><span class="line">  color: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"class"</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"class1"</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> &gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1d"</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1d.com"</span>&gt;</span>a2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3d"</span>&gt;</span>a3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="美化网页元素"><a href="#美化网页元素" class="headerlink" title="美化网页元素"></a>美化网页元素</h2><h3 id="1-字体样式"><a href="#1-字体样式" class="headerlink" title="1.字体样式"></a>1.字体样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Kaiti SC"</span>;<span class="comment">/*字体*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;<span class="comment">/*字体大小*/</span></span><br><span class="line">    <span class="attribute">font-weight</span>: bold;<span class="comment">/*字体粗细*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*简化写法*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">font</span>: bold <span class="number">50px</span> <span class="string">"Kaiti SC"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-文本样式"><a href="#2-文本样式" class="headerlink" title="2.文本样式"></a>2.文本样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  	<span class="comment">/*color颜色表示方式*/</span></span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0000ff</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line">  	<span class="comment">/*rgba代表在传统rgb上添加a,表示透明度*/</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0%</span>,<span class="number">100%</span>,<span class="number">100%</span>,<span class="number">0.3</span>);</span><br><span class="line">  	<span class="comment">/*text-align表示文本对齐方式*/</span></span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">  	<span class="comment">/*text-indent表示文本首行缩进字符*/</span></span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">  	<span class="comment">/*line-height表示行高，当line-height同当前块height同高度，则可以实现文本上下居中效果*/</span></span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  	<span class="comment">/*text-decoration表示文本装饰线*/</span></span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;<span class="comment">/*下滑线*/</span></span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through;<span class="comment">/*中滑线*/</span></span><br><span class="line">    <span class="attribute">text-decoration</span>: overline;<span class="comment">/*上滑线*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-超链接样式"><a href="#3-超链接样式" class="headerlink" title="3.超链接样式"></a>3.超链接样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*点击超链接之后未离开的样式*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;&#125;</span><br><span class="line"><span class="comment">/*悬停在超链接上的样式*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;&#125;</span><br><span class="line"><span class="comment">/*未点击之前的链接样式*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;&#125;</span><br><span class="line"><span class="comment">/*已点击后的链接样式*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-列表样式"><a href="#4-列表样式" class="headerlink" title="4.列表样式"></a>4.列表样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">  <span class="comment">/*无序列表前序样式*/</span></span><br><span class="line">  <span class="attribute">list-style</span>: none;<span class="comment">/*去除无序列表黑点*/</span></span><br><span class="line">  <span class="attribute">list-style</span>: circle;<span class="comment">/*无序列表黑点变为空心圆点*/</span></span><br><span class="line">  <span class="attribute">list-style</span>: square;<span class="comment">/*无序列表黑点变为正方形块*/</span></span><br><span class="line">  <span class="attribute">list-style</span>: decimal;<span class="comment">/*无序列表黑点变为有序列表*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-背景样式"><a href="#5-背景样式" class="headerlink" title="5.背景样式"></a>5.背景样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  	<span class="comment">/*边框样式*/</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  	<span class="comment">/*背景图片*/</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"path"</span>);</span><br><span class="line">  	<span class="comment">/*背景图片填充方式：no-repeat表示不填充,repeat-x表示按x轴填充*/</span></span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  	<span class="comment">/*背景图片填充之后图片定位，x轴右向为正，y轴下向为正*/</span></span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">100px</span> <span class="number">60px</span>;</span><br><span class="line">  	<span class="comment">/*上述缩写方式*/</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"path"</span>) <span class="number">100px</span> <span class="number">60px</span> no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="1-什么是盒子模型"><a href="#1-什么是盒子模型" class="headerlink" title="1.什么是盒子模型"></a>1.什么是盒子模型</h3><p>盒子模型包含三个要素，分别是：</p>
<ul>
<li>外边距<strong>margin</strong></li>
<li>边框<strong>border</strong></li>
<li>内边距<strong>padding</strong></li>
</ul>
<h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  <span class="comment">/*margin的初始化：</span></span><br><span class="line"><span class="comment">  	margin赋值顺序为上-右-下-左对称复制模式：</span></span><br><span class="line"><span class="comment">  	margin:0; 表示四个方向边距均为0</span></span><br><span class="line"><span class="comment">  	margin:0 1px; 表示上边距为0，右边距为1px，下边距为0，左边距为1px</span></span><br><span class="line"><span class="comment">  	margin:0 1px 2px; 表示上边距为0，右边距为1px，下边距为2px，左边距为1px</span></span><br><span class="line"><span class="comment">  	margin:0 1px 2px 3px; 表示上边距为0，右边距为1px，下边距为2px，左边距为3px</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSS定位机制"><a href="#CSS定位机制" class="headerlink" title="CSS定位机制"></a>CSS定位机制</h2><h3 id="1-文档流定位"><a href="#1-文档流定位" class="headerlink" title="1.文档流定位"></a>1.文档流定位</h3><ul>
<li>元素分类：<ul>
<li><strong>block块级元素</strong>：独占一行，eg:h1～h6,div,p,ul…</li>
<li><strong>inline行内元素</strong>：不独占一行，eg:span,img,a,strong…</li>
<li><strong>inline-block行块级元素</strong>：不单独占用一行，但是可以设置height等block独有的属性。</li>
</ul>
</li>
<li>元素类型转换：<strong>display</strong>强制转换——<strong>用于导航栏设计</strong></li>
</ul>
<h3 id="2-浮动定位"><a href="#2-浮动定位" class="headerlink" title="2.浮动定位"></a>2.浮动定位</h3><ul>
<li><p><strong>float属性</strong>：left,right,none，使得块级元素向左/右/不浮动</p>
</li>
<li><p><strong>clear属性</strong>：left,right,none，清除块级元素向左/右/两边浮动属性</p>
<p>clear属性用于盒子模型排列不整齐时可以通过清除浮动特性获得更好的排列效果。</p>
</li>
<li><p><strong>父级边框塌缩问题：</strong></p>
<ol>
<li><p>增加父级元素高度</p>
</li>
<li><p>父级元素内底部增加div标签清除浮动：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div id="father"&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;div class="div"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>overflow：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div id="father"&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="selector-id">#father</span>&#123;</span><br><span class="line">  <span class="comment">/*overflow属性：当内容溢出盒子边框时调用*/</span></span><br><span class="line">  <span class="comment">/*hidden：隐藏溢出部分</span></span><br><span class="line"><span class="comment">  	scroll：显示滚动条</span></span><br><span class="line"><span class="comment">  	auto：如果有溢出部分显示滚动条</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在父级元素之后添加伪类after</strong>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#father</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*效果等同于方法2*/</span></span><br><span class="line"><span class="selector-id">#father</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-层定位"><a href="#3-层定位" class="headerlink" title="3.层定位"></a>3.层定位</h3></li>
</ol>
</li>
<li><p><strong>position属性：</strong></p>
<ul>
<li><strong>static：</strong>默认值，没有定位关系。</li>
<li><strong>fixed：</strong>固定定位，相对于浏览器窗口。</li>
<li><strong>relative：</strong>相对定位，相对于直接父元素，<font color="ff0000">relative脱离正常的文本流，但是其在文本流中的原始位置依然存在。</font></li>
<li><strong>absolute：</strong>绝对定位，相对于static以外的第一个父级元素，<font color="ff0000">absolute脱离文本流，而且正常流中的原位置不再存在。</font></li>
</ul>
</li>
<li><p><strong>位置属性：</strong>left,right,top,bottom：相对于左/右/上/下偏移距离（正值默认反向）</p>
</li>
<li><p><strong>z-index属性：</strong>图层属性，默认值0，值越大说明优先级越高。</p>
</li>
</ul>
<h2 id="CSS变换"><a href="#CSS变换" class="headerlink" title="CSS变换"></a>CSS变换</h2><h3 id="1-2D变换"><a href="#1-2D变换" class="headerlink" title="1.2D变换"></a>1.2D变换</h3><p><strong>transform属性：旋转，缩放，移动，拉伸</strong></p>
<ul>
<li><strong>rotate(deg):旋转</strong>，正值顺时针旋转，负值逆时针旋转。</li>
<li><strong>scale(x,y)：缩放</strong>，x表示水平方向缩放的倍数;y表示垂直方向缩放的倍数，范围0-1内表示缩小，&gt;1表示放大。</li>
</ul>
<h3 id="2-过渡与动画"><a href="#2-过渡与动画" class="headerlink" title="2.过渡与动画"></a>2.过渡与动画</h3><ul>
<li><p><strong>transition：</strong>过渡，指元素某个属性从一个值过渡到另一个值</p>
<ul>
<li>transition-property:属性名</li>
<li>transition-duration:持续时间</li>
<li>transition-timing-function:过渡方法：ease:慢;linear:匀速;ease-in-out:慢快慢</li>
<li>transition-delay:延迟时间</li>
</ul>
</li>
<li><p><strong>animation：</strong></p>
</li>
</ul>
<ol>
<li>定义动画：@keyframes规则</li>
<li>调用动画：animation属性：属性名-时间-方法</li>
</ol>
<h3 id="3-3D变换"><a href="#3-3D变换" class="headerlink" title="3.3D变换"></a>3.3D变换</h3><ol>
<li>设定3D变换：<font color="ff0000">transform-style:preserve-3d</font></li>
<li>设定transform变换属性：rotateX(deg)/rotateY(deg)/rotateZ(deg),旋转变换角度</li>
<li>设定perspective透视属性：近大远小，单位px</li>
</ol>
<p>其中1和2组成父容器，3组成舞台，即眼睛到舞台的距离，通过perspective实现3D效果。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础语法学习笔记</title>
    <url>/2020/07/28/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要是总结一些Java的基础知识，主要是用来记录自己的学习过程与学习心得。</p>
<a id="more"></a>

<h2 id="第一章：基础语法整理"><a href="#第一章：基础语法整理" class="headerlink" title="第一章：基础语法整理"></a>第一章：基础语法整理</h2><h3 id="String拼接"><a href="#String拼接" class="headerlink" title="String拼接"></a>String拼接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ... </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="comment">//以下两条代码输出结果均为String类型</span></span><br><span class="line">System.out.println(<span class="string">""</span>+a+b);</span><br><span class="line"><span class="comment">//输出1020</span></span><br><span class="line">System.out.println(a+b+<span class="string">""</span>);</span><br><span class="line"><span class="comment">//输出30</span></span><br></pre></td></tr></table></figure>

<h3 id="Scanner用法"><a href="#Scanner用法" class="headerlink" title="Scanner用法"></a>Scanner用法</h3><ol>
<li><p>获取系统输入流：new scanner(System.in)</p>
</li>
<li><p>判断输入截止：hasNext()/hasNextLine</p>
</li>
<li><p>获取用户输入信息：scanner.next()/scanner.nextLine()</p>
</li>
<li><p>关闭scanner方法：scanner.close()</p>
<p>完整代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputScnner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"please input a string:"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Java-Scnner输入流</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				next方法：</span></span><br><span class="line"><span class="comment">				1.只有在遇到有效字符才正式生效，即开始输入的若干空格字符不被正常识别记录</span></span><br><span class="line"><span class="comment">				2.有效字符之后遇到空格的元素被剔除</span></span><br><span class="line"><span class="comment">				3.以Enter作为截止输入符</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//next() </span></span><br><span class="line">        <span class="keyword">if</span>(scanner.hasNext())&#123;</span><br><span class="line">            String str = scanner.next();</span><br><span class="line">            System.out.println(<span class="string">"output is "</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				nextLine方法：</span></span><br><span class="line"><span class="comment">				1.以Enter作为截止输入符</span></span><br><span class="line"><span class="comment">				2.即Enter之前的所有的符号均可被正常识别记录</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//nextLine() </span></span><br><span class="line">        <span class="keyword">if</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String str = scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"output is "</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//close scnner</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="switch-case穿透"><a href="#switch-case穿透" class="headerlink" title="switch case穿透"></a>switch case穿透</h3><p>switch-case匹配结构中，若case分支不存在break语句且当前条件匹配该case，则直接执行此case及之后所有case分支语句，直到遇到下一个break停止执行,代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 如果当前I1值为B，则匹配第二个case语句，程序整体输出B所在case语句之后所有sout语句，</span></span><br><span class="line"><span class="comment"> 直至遇到break为止，若D所在case语句也不存在break，则default语句依旧被输出。</span></span><br><span class="line"><span class="comment"> 输出结果为：</span></span><br><span class="line"><span class="comment"> Nice!</span></span><br><span class="line"><span class="comment"> ohyeah!</span></span><br><span class="line"><span class="comment"> shit!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">switch</span> (I1)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                System.out.println(<span class="string">"Good!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                System.out.println(<span class="string">"Nice!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">                System.out.println(<span class="string">"ohyeah!"</span>);</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line">                System.out.println(<span class="string">"shit!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"Wrong!"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(a);<span class="comment">//输出 a = 1</span></span><br><span class="line">        Test.change(a);</span><br><span class="line">        System.out.println(a);<span class="comment">//输出 a = 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.name = <span class="string">"lisi"</span>;</span><br><span class="line">        System.out.println(person.name);<span class="comment">//输出 lisi</span></span><br><span class="line">        Test.change(person);</span><br><span class="line">        System.out.println(person.name);<span class="comment">//输出 zhangsan</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        person.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ol>
<li>JDK 1.5新增功能</li>
<li>在方法声明中，在指定参数类型后添加省略号(…)</li>
<li>一个方法中只能声明一个可变参数，<font color ="ff0000">它必须是方法的最后一个参数</font>，任何其他普通参数均需在其之前声明。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printMaxmum(<span class="number">1.2</span>,<span class="number">323</span>,<span class="number">12</span>,<span class="number">44</span>,<span class="number">4.5</span>);</span><br><span class="line">        printMaxmum(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7.7</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//可变参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMaxmum</span><span class="params">(<span class="keyword">double</span>... number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number.length==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"no number"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> max = number[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (number[i]&gt;max)</span><br><span class="line">                max=number[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"the max value is :"</span>+max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrays_one = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[][] arrays_two = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//JDK1.5新增功能</span></span><br><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> array:arrays_one)</span><br><span class="line">&#123;</span><br><span class="line">  System.out.println(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] ints:arrays_two)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> anInt:ints)</span><br><span class="line">    System.out.println(anInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二维数组创建</span></span><br><span class="line">        System.out.println(<span class="string">"please input matrix's nums,lins and cows:"</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> sum = scanner.nextInt();<span class="comment">//有效值总数</span></span><br><span class="line">        <span class="keyword">int</span> lin = scanner.nextInt();<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> cow = scanner.nextInt();<span class="comment">//列数</span></span><br><span class="line">				<span class="comment">//初始化二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arrays_two = <span class="keyword">new</span> <span class="keyword">int</span>[lin][cow];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"please input the value and its position: "</span>);</span><br><span class="line">            <span class="keyword">int</span> num_v = scanner.nextInt();<span class="comment">//元素值</span></span><br><span class="line">            <span class="keyword">int</span> lin_l = scanner.nextInt();<span class="comment">//对应的行数</span></span><br><span class="line">            <span class="keyword">int</span> cow_c = scanner.nextInt();<span class="comment">//对应的列数</span></span><br><span class="line"></span><br><span class="line">            arrays_two[lin_l-<span class="number">1</span>][cow_c-<span class="number">1</span>] = num_v;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//输出二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : arrays_two) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        初始化稀疏数组，其中行数为有效数字个数+1，列数固定3列</span></span><br><span class="line"><span class="comment">        其中第一行存放稀疏数组的有效值个数，行数，列数</span></span><br><span class="line"><span class="comment">        其余行存放对应的有效值以及其行列数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[][] arrays_xishu = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        arrays_xishu[<span class="number">0</span>][<span class="number">0</span>] = sum;</span><br><span class="line">        arrays_xishu[<span class="number">0</span>][<span class="number">1</span>] = arrays_two.length;</span><br><span class="line">        arrays_xishu[<span class="number">0</span>][<span class="number">2</span>] = arrays_two[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//遍历原数组，将有效值存放于稀疏数组中</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays_two.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrays_two[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arrays_two[i][j]!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    arrays_xishu[count][<span class="number">0</span>] = arrays_two[i][j];</span><br><span class="line">                    arrays_xishu[count][<span class="number">1</span>] = i+<span class="number">1</span>;</span><br><span class="line">                    arrays_xishu[count][<span class="number">2</span>] = j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">"稀疏数组如下所示："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : arrays_xishu) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二章：面向对象思想"><a href="#第二章：面向对象思想" class="headerlink" title="第二章：面向对象思想"></a>第二章：面向对象思想</h2><h3 id="面向对象和类"><a href="#面向对象和类" class="headerlink" title="面向对象和类"></a>面向对象和类</h3><ul>
<li><p>构造函数</p>
<ul>
<li>必须和类名一样，且没有返回值。</li>
<li><font color ="ff0000">new 本质是在调用构造方法，初始化对象的值。</font></li>
<li>定义有参构造之后，若想使用无参构造，需显示定义一个无参构造。</li>
</ul>
</li>
<li><p>析构函数</p>
<p>Java不存在析构函数,Java具有内存回收机制，当变量退出其生命周期时，JVM会自动识别并调用垃圾回收器GC。</p>
</li>
<li><p>Java类访问权限</p>
<table>
<thead>
<tr>
<th></th>
<th>同一个类</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>不同包的非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>遵循原则：高内聚，低耦合</strong></p>
<ul>
<li>保护属性信息：类的成员属性是私有的private<ul>
<li>获取类成员属性可以使用getter &amp; setter 方法，对应IDEA工具 mac快捷键：command+return；windows快捷键：alt+inter</li>
</ul>
</li>
<li>公开行为信息：类的方法是公有的public</li>
<li>this关键字<ul>
<li>this负责指向本类中的成员变量</li>
<li>this负责指向本类中的成员方法</li>
<li>this可以代替本类的构造函数</li>
</ul>
</li>
<li>this示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OO类声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       gets obj = <span class="keyword">new</span> gets(<span class="number">5</span>);  </span><br><span class="line">       System.out.println(obj.sum());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gets类声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">gets</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设定私有变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="comment">//类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">gets</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(m,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">gets</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m=m;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sum方法调用add方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.add(m,n);<span class="comment">//可省略this因为不会引起歧义</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m+n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>继承是类与类之间的一种关系，除此之外，类与类之间还可以存在依赖、组合、聚合等关系。</p>
</li>
<li><p>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字<strong>extendes</strong>。</p>
</li>
<li><div><font color = "ff0000">Java中类只有单继承，没有多继承,其中object类是所有类的父类。</font></div>

</li>
</ul>
<p><strong>super关键字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//！！默认隐藏调用父类的！无参！构造函数！！</span></span><br><span class="line">      	<span class="comment">//如果调用有参构造函数，需显示声明super()方法</span></span><br><span class="line">      	<span class="comment">//super();</span></span><br><span class="line">        System.out.println(<span class="string">"Student无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"bushizhangsan"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name);<span class="comment">//输出当前name</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//输出当前类对应的name</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name);<span class="comment">//输出父类对应的name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.test(<span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出</span></span><br><span class="line">Person无参构造</span><br><span class="line">Student无参构造</span><br><span class="line">张三</span><br><span class="line">bushizhangsan</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure>

<p><strong>方法重写</strong></p>
<ol>
<li>方法名必须相同，参数列表必须相同。</li>
<li>修饰符：继承子类属性的范围相较父类属性可以扩大，但不可以缩小：public&gt;protected&gt;default&gt;private</li>
<li>抛出异常范围：可以被缩小，但不可以被扩大：ClassNotFoundException –&gt; Exception(大)</li>
<li>重写前后子类方法名必须和父类一致，但是方法体可以不同。</li>
</ol>
<ul>
<li><p>静态方法重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person=&gt;test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student=&gt;test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.test();</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();<span class="comment">//延伸创建父类对象</span></span><br><span class="line">        person.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Student=&gt;test</span><br><span class="line">Person=&gt;test</span><br></pre></td></tr></table></figure>
</li>
<li><p>非静态方法重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person=&gt;test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  	<span class="meta">@Override</span><span class="comment">//注解：有功能的注释</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student=&gt;test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.test();</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();<span class="comment">//重写父类方法</span></span><br><span class="line">        person.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Student=&gt;test</span><br><span class="line">Student=&gt;test</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li><p>多态即同一种对象可以根据发送对象的不同而采取多种不同的行为方式，即对函数而言，<font color="ff0000">取决于左部类型信息。</font></p>
</li>
<li><p>多态存在条件：有继承关系、子类重写父类方法、父类引用子类对象。</p>
</li>
<li><p>多态本质是父类引用指向子类的对象，子类转换为父类，向上转型；<font color ="ff0000">父类转换为子类，向下转型，须强制转换。</font></p>
</li>
</ul>
<p><strong>static关键词</strong></p>
<ul>
<li><p>static静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  	<span class="comment">//1.随类加载时一同执行，且只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//2.完成类的初始操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"匿名代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//3.当类的初始操作完成后执行构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">静态代码块</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br><span class="line">===============</span><br><span class="line">匿名代码块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>static静态导入包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"匿名代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(random());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">静态代码块</span><br><span class="line"><span class="number">0.9107008895679277</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li><p>抽象类不能使用new关键字来创建对象，只能通过子类继承来实现。</p>
</li>
<li><p>抽象方法只有方法的声明，没有方法的实现。</p>
</li>
<li><p><strong>abstract</strong>修饰符可以用来修饰方法也可以用来修饰类，若修饰方法，则该方法是抽象方法；若修饰类，则该类是抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注：抽象类中也是可以有构造函数的。虽然抽象类不能实例化，但是抽象类被继承之后，它的派生类可以实例化；而派生类在实例化调用构造函数的时候会先调用基类中的构造函数，所以抽象类的构造函数也是可以被调用的，所以抽象类中可以有构造函数。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><table>
<thead>
<tr>
<th>JavaOOD思想</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>普通类</td>
<td>只有具体的实现</td>
</tr>
<tr>
<td>抽象类</td>
<td>具体实现和规范（抽象方法）</td>
</tr>
<tr>
<td>接口</td>
<td>只有规范</td>
</tr>
</tbody></table>
<ul>
<li><p>接口是一种规范，定义了一组规则，体现了现实世界中“如果你是…则必须能…”的思想。</p>
</li>
<li><p><font color="ff0000">接口本质是一种契约</font>，相当于一种Java的法律规范。</p>
</li>
<li><p>声明类的关键字是class，声明接口的关键字是<strong>interface</strong>。</p>
</li>
<li><p>接口中所有的方法均默认<strong>public abstract</strong>,所有常量默认<strong>public static final</strong>。</p>
</li>
<li><p>实现接口方法通过子类<strong>implements</strong>关键词实现，<font color="ff0000">同时子类可以实现多个接口。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">userService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现</span></span><br><span class="line"><span class="keyword">import</span> .../.userService;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">userService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">10</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Outer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"this is Inner"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过内部类获取外部私有信息</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getID</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        inner.getID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="第三章：Java常用类"><a href="#第三章：Java常用类" class="headerlink" title="第三章：Java常用类"></a>第三章：Java常用类</h2><ol>
<li><p>Math–BigDecimal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="string">"1234"</span>);</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="string">"1234"</span>);</span><br><span class="line">        BigDecimal b3 = b1.divide(b2,<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String a = <span class="string">"123;456;789;123 "</span>;</span><br><span class="line">		System.out.println(a.charAt(<span class="number">0</span>)); <span class="comment">// 返回第0个元素</span></span><br><span class="line">		System.out.println(a.indexOf(<span class="string">";"</span>)); <span class="comment">// 返回第一个;的位置</span></span><br><span class="line">		System.out.println(a.concat(<span class="string">";000"</span>)); <span class="comment">// 连接一个新字符串并返回，a不变</span></span><br><span class="line">		System.out.println(a.contains(<span class="string">"000"</span>)); <span class="comment">// 判断a是否包含000</span></span><br><span class="line">		System.out.println(a.endsWith(<span class="string">"000"</span>)); <span class="comment">// 判断a是否以000结尾</span></span><br><span class="line">		System.out.println(a.equals(<span class="string">"000"</span>)); <span class="comment">// 判断是否等于000</span></span><br><span class="line">		System.out.println(a.equalsIgnoreCase(<span class="string">"000"</span>));<span class="comment">// 判断在忽略大小写情况下是否等于000</span></span><br><span class="line">		System.out.println(a.length()); <span class="comment">// 返回a长度</span></span><br><span class="line">		System.out.println(a.trim()); <span class="comment">// 返回a去除前后空格后的字符串，a不变</span></span><br><span class="line">		String[] b = a.split(<span class="string">";"</span>); <span class="comment">// 将a字符串按照;分割成数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">			System.out.println(b[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(a.substring(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 截取a的第2个到第5个字符 a不变</span></span><br><span class="line">		System.out.println(a.replace(<span class="string">"1"</span>, <span class="string">"a"</span>));</span><br><span class="line">		System.out.println(a.replaceAll(<span class="string">"1"</span>, <span class="string">"a"</span>)); <span class="comment">// replaceAll第一个参数是正则表达式</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"></span><br><span class="line">		String s1 = <span class="string">"12345?6789"</span>;</span><br><span class="line">		String s2 = s1.replace(<span class="string">"?"</span>, <span class="string">"a"</span>);</span><br><span class="line">		String s3 = s1.replaceAll(<span class="string">"[?]"</span>, <span class="string">"a"</span>);</span><br><span class="line">		<span class="comment">// 这里的[?] 才表示字符问号，这样才能正常替换。不然在正则中会有特殊的意义就会报异常</span></span><br><span class="line">		System.out.println(s2);</span><br><span class="line">		System.out.println(s3);</span><br><span class="line">		System.out.println(s1.replaceAll(<span class="string">"[\\d]"</span>, <span class="string">"a"</span>)); <span class="comment">//将s1内所有数字替换为a并输出，s1的值未改变。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Time</p>
</li>
<li><p>Format</p>
</li>
</ol>
<h2 id="第四章：Java异常处理"><a href="#第四章：Java异常处理" class="headerlink" title="第四章：Java异常处理"></a>第四章：Java异常处理</h2><ul>
<li><p>Java异常包含<strong>Throwable、Error和Exception</strong>三类，其中<strong>Throwable</strong>是所有错误的祖先，<strong>Error</strong>是系统内部错误，<strong>Exception</strong>是程序有关的异常。</p>
</li>
<li><p>Java采取<strong>try-catch-finally框架</strong>处理异常结构，其中try负责正常的业务逻辑代码，catch负责捕捉try抛出的异常类型，finally则在try-catch最后执行。<strong><font color ="ff0000">try必须存在，catch和finally至少有一个</font></strong>，且三个模块均可在内部嵌套<strong>try-catch-finally框架</strong>。</p>
</li>
<li><p>catch块可类比case，可以有多个，进入入口取决于try抛出的异常，当抛出异常同某个catch块中的形参类型一致，则执行该catch块代码。<strong><font color ="ff0000">进入catch块后，并不会返回到try发生的位置，也不会执行后续的catch块，一个异常只能进入一个catch块。</font></strong></p>
</li>
<li><p>throws异常处理中，若该方法被覆盖，<strong><font color="ff0000">覆盖它的方法必须抛出相同的异常，或者异常的子类。</font></strong>即父类方法抛出的异常，子类方法必须同样抛出那些异常或者异常的真子集，也就是不能抛出新的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a = <span class="number">5</span>/<span class="number">2</span>; <span class="comment">//无异常</span></span><br><span class="line">			System.out.println(<span class="string">"a is "</span> + a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"Phrase 1 is over"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a = <span class="number">5</span>/<span class="number">0</span>; <span class="comment">//ArithmeticException</span></span><br><span class="line">			System.out.println(<span class="string">"a is "</span> + a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"Phrase 2 is over"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a = <span class="number">5</span>/<span class="number">0</span>; <span class="comment">//ArithmeticException</span></span><br><span class="line">			System.out.println(<span class="string">"a is "</span> + a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">			<span class="keyword">int</span> a = <span class="number">5</span>/<span class="number">0</span>; <span class="comment">//ArithmeticException</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"Phrase 3 is over"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="第五章：Java文件读写"><a href="#第五章：Java文件读写" class="headerlink" title="第五章：Java文件读写"></a>第五章：Java文件读写</h2><h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java - IO"></a>Java - IO</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileAttributeTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建目录</span></span><br><span class="line">	File d=<span class="keyword">new</span> File(<span class="string">"c:/temp"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!d.exists())</span><br><span class="line">	&#123;</span><br><span class="line">		d.mkdirs();  <span class="comment">//mkdir 创建单级目录  mkdirs 连续创建多级目录</span></span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"Is d directory? "</span> + d.isDirectory());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建文件  </span></span><br><span class="line">    File f=<span class="keyword">new</span> File(<span class="string">"C:/temp/abc.txt"</span>);    </span><br><span class="line">    <span class="keyword">if</span>(!f.exists())</span><br><span class="line">    &#123;    	</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">        f.createNewFile(); <span class="comment">//创建abc.txt</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span>(IOException e)&#123; <span class="comment">//可能会因为权限不足或磁盘已满报错</span></span><br><span class="line">    	  e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出文件相关属性</span></span><br><span class="line">    System.out.println(<span class="string">"Is f file? "</span> + f.isFile());</span><br><span class="line">    System.out.println(<span class="string">"Name: "</span>+f.getName());</span><br><span class="line">    System.out.println(<span class="string">"Parent: "</span>+f.getParent());</span><br><span class="line">    System.out.println(<span class="string">"Path: "</span>+f.getPath());</span><br><span class="line">    System.out.println(<span class="string">"Size: "</span>+f.length()+<span class="string">" bytes"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Last modified time: "</span>+f.lastModified()+<span class="string">"ms"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历d目录下所有的文件信息</span></span><br><span class="line">    System.out.println(<span class="string">"list files in d directory"</span>);</span><br><span class="line">    File[] fs = d.listFiles();  <span class="comment">//列出d目录下所有的子文件，不包括子目录下的文件</span></span><br><span class="line">    <span class="keyword">for</span>(File f1:fs)</span><br><span class="line">    &#123;</span><br><span class="line">    	System.out.println(f1.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//f.delete(); //删除此文件</span></span><br><span class="line">    <span class="comment">//d.delete(); //删除目录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java - NIO"></a>Java - NIO</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.DirectoryStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.LinkOption;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardCopyOption;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		moveFile();</span><br><span class="line">		fileAttributes();</span><br><span class="line">		createDirectory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Path from = Paths.get(<span class="string">"c:/temp"</span>, <span class="string">"abc.txt"</span>);</span><br><span class="line">		<span class="comment">//移动c:/temp/abc.txt到c:/temp/test/def.txt，如目标文件已存在，就替换</span></span><br><span class="line">		Path to = from.getParent().resolve(<span class="string">"test/def.txt"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//文件的大小bytes</span></span><br><span class="line">			System.out.println(Files.size(from));</span><br><span class="line">			<span class="comment">//调用文件移动方法  如果目标文件已经存在，就替换</span></span><br><span class="line">			Files.move(from, to, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"移动文件错误"</span> + e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileAttributes</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Path path = Paths.get(<span class="string">"c:/temp"</span>);</span><br><span class="line">		<span class="comment">//1</span></span><br><span class="line">		System.out.println(Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line">		<span class="comment">//2</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//获得文件的基础属性</span></span><br><span class="line">			BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			System.out.println(attributes.isDirectory());</span><br><span class="line">			System.out.println(<span class="keyword">new</span> Date(attributes.lastModifiedTime().toMillis()).toLocaleString());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDirectory</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Path path = Paths.get(<span class="string">"c:/temp/test"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//创建文件夹</span></span><br><span class="line">			<span class="keyword">if</span>(Files.notExists(path))&#123;</span><br><span class="line">				Files.createDirectories(path);</span><br><span class="line">				System.out.println(<span class="string">"create dir"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"dir exists"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			Path path2 = path.resolve(<span class="string">"A.java"</span>); </span><br><span class="line">			Path path3 = path.resolve(<span class="string">"B.java"</span>);</span><br><span class="line">			Path path4 = path.resolve(<span class="string">"C.txt"</span>);</span><br><span class="line">			Path path5 = path.resolve(<span class="string">"D.jpg"</span>);</span><br><span class="line">			Files.createFile(path2);</span><br><span class="line">			Files.createFile(path3);</span><br><span class="line">			Files.createFile(path4);</span><br><span class="line">			Files.createFile(path5);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//不加条件遍历</span></span><br><span class="line">			DirectoryStream&lt;Path&gt; paths = Files.newDirectoryStream(path);</span><br><span class="line">			<span class="keyword">for</span>(Path p : paths)&#123;</span><br><span class="line">				System.out.println(p.getFileName());</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建一个带有过滤器,过滤文件名以java txt结尾的文件</span></span><br><span class="line">			DirectoryStream&lt;Path&gt; pathsFilter = Files.newDirectoryStream(path, <span class="string">"*.&#123;java,txt&#125;"</span>);</span><br><span class="line">			<span class="keyword">for</span>(Path p : pathsFilter)&#123;</span><br><span class="line">				System.out.println(p.getFileName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第六章：Java常用数据结构"><a href="#第六章：Java常用数据结构" class="headerlink" title="第六章：Java常用数据结构"></a>第六章：Java常用数据结构</h2><h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h3><ul>
<li><p>List是有序的Collection，允许重复元素。</p>
</li>
<li><p>List主要实现：<strong>ArrayList</strong>（非同步）、<strong>LinkedList</strong>（非同步）、<strong>Vector</strong>（同步）</p>
<ol>
<li><p><strong>ArrayList</strong></p>
<ul>
<li><p><strong>以数组实现的列表，不支持同步</strong></p>
<p>• <strong>List list = Collections.synchronizedList(new ArrayList(…));</strong></p>
</li>
<li><p><strong>利用索引位置可以快速定位访问</strong></p>
</li>
<li><p><strong>不适合指定位置的插入、删除操作</strong></p>
</li>
<li><p><strong>适合变动不大，主要用于查询的数据</strong></p>
</li>
<li><p><strong>和Java数组相比，其容量是可动态调整的</strong></p>
</li>
<li><p><strong>ArrayList在元素填满容器时会自动扩充容器大小的50%</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">//Vector 几乎和ArrayList一样，除了Vector本身是同步的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;  </span><br><span class="line">	    ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">	    al.add(<span class="number">3</span>);  </span><br><span class="line">	    al.add(<span class="number">2</span>);          </span><br><span class="line">	    al.add(<span class="number">1</span>);  </span><br><span class="line">	    al.add(<span class="number">4</span>);  </span><br><span class="line">	    al.add(<span class="number">5</span>);  </span><br><span class="line">	    al.add(<span class="number">6</span>);  </span><br><span class="line">	    al.add(<span class="keyword">new</span> Integer(<span class="number">6</span>));  </span><br><span class="line">	  </span><br><span class="line">	    System.out.print(<span class="string">"The third element is  "</span>);</span><br><span class="line">	    System.out.println(al.get(<span class="number">3</span>));</span><br><span class="line">	    al.remove(<span class="number">3</span>);  <span class="comment">//删除第四个元素，后面元素往前挪动</span></span><br><span class="line">	    al.add(<span class="number">3</span>, <span class="number">9</span>);  <span class="comment">//将9插入到第4个元素，后面元素往后挪动</span></span><br><span class="line">	    </span><br><span class="line">	    System.out.println(<span class="string">"======遍历方法============="</span>);</span><br><span class="line">	    </span><br><span class="line">	    ArrayList&lt;Integer&gt; as = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">100000</span>);</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	as.add(i);</span><br><span class="line">	    &#125;</span><br><span class="line">    	<span class="comment">//三种遍历方式性能比较</span></span><br><span class="line">    	<span class="comment">//for-each &gt; 随机索引值遍历 &gt; 迭代器遍历</span></span><br><span class="line">	    traverseByIterator(as);</span><br><span class="line">	    traverseByIndex(as);</span><br><span class="line">	    traverseByFor(as);    </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIterator</span><span class="params">(ArrayList&lt;Integer&gt; al)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============迭代器遍历=============="</span>); </span><br><span class="line">	    Iterator&lt;Integer&gt; iter1 = al.iterator();  </span><br><span class="line">	    <span class="keyword">while</span>(iter1.hasNext())&#123;  </span><br><span class="line">	        iter1.next();  </span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIndex</span><span class="params">(ArrayList&lt;Integer&gt; al)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============随机索引值遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;al.size();i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	al.get(i);</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByFor</span><span class="params">(ArrayList&lt;Integer&gt; al)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(Integer item : al)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LinkedList</strong></p>
<ul>
<li><p><strong>以双向链表实现的列表，不支持同步</strong></p>
<p>• <strong>List list = Collections.synchronizedList(new LinkedList(…));</strong></p>
</li>
<li><p><strong>可被当作堆栈、队列和双端队列进行操作</strong></p>
</li>
<li><p><strong>顺序访问高效，随机访问较差，中间插入和删除高效</strong></p>
</li>
<li><p><strong>适用于经常变化的数据</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; ll = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();  </span><br><span class="line">	    ll.add(<span class="number">3</span>);  </span><br><span class="line">	    ll.add(<span class="number">2</span>);  </span><br><span class="line">	    ll.add(<span class="number">5</span>);  </span><br><span class="line">	    ll.add(<span class="number">6</span>);  </span><br><span class="line">	    ll.add(<span class="number">6</span>);  </span><br><span class="line">	    System.out.println(ll.size());</span><br><span class="line">	    ll.addFirst(<span class="number">9</span>);  <span class="comment">//在头部增加9</span></span><br><span class="line">	    ll.add(<span class="number">3</span>, <span class="number">10</span>);   <span class="comment">//将10插入到第四个元素，四以及后续的元素往后挪动</span></span><br><span class="line">	    ll.remove(<span class="number">3</span>);    <span class="comment">//将第四个元素删除</span></span><br><span class="line">	    </span><br><span class="line">	    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	list.add(i);</span><br><span class="line">	    &#125;</span><br><span class="line">    	<span class="comment">//三种遍历方式性能比较</span></span><br><span class="line">    	<span class="comment">//for-each &gt; 迭代器遍历 &gt; 随机索引值遍历</span></span><br><span class="line">	    traverseByIterator(list);</span><br><span class="line">	    traverseByIndex(list);</span><br><span class="line">	    traverseByFor(list);    </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIterator</span><span class="params">(LinkedList&lt;Integer&gt; list)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============迭代器遍历=============="</span>); </span><br><span class="line">	    Iterator&lt;Integer&gt; iter1 = list.iterator();  </span><br><span class="line">	    <span class="keyword">while</span>(iter1.hasNext())&#123;  </span><br><span class="line">	        iter1.next();  </span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIndex</span><span class="params">(LinkedList&lt;Integer&gt; list)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============随机索引值遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	list.get(i);</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByFor</span><span class="params">(LinkedList&lt;Integer&gt; list)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(Integer item : list)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color ="ff0000">ArrayList适用于较多的查询情况，LinkedList适用于较多的增删情况。</font></strong></p>
</li>
<li><p><strong>Vector</strong></p>
<ul>
<li><p><strong>和ArrayList类似，可变数组实现的列表</strong></p>
</li>
<li><p><strong>Vector同步，适合在多线程下使用</strong></p>
</li>
<li><p><strong>原先不属于JCF框架，属于Java最早的数据结构，性能较差</strong></p>
</li>
<li><p><strong>从JDK1.2开始，Vector被重写，并纳入到JCF</strong></p>
</li>
<li><p><strong>官方文档建议在非同步情况下，优先采用ArrayList</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Vector&lt;Integer&gt; v = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">		v.add(<span class="number">1</span>);</span><br><span class="line">		v.add(<span class="number">2</span>);</span><br><span class="line">		v.add(<span class="number">3</span>);</span><br><span class="line">		v.remove(<span class="number">2</span>);</span><br><span class="line">		v.add(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(v.size());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"======遍历方法============="</span>);</span><br><span class="line"></span><br><span class="line">		Vector&lt;Integer&gt; v2 = <span class="keyword">new</span> Vector&lt;Integer&gt;(<span class="number">100000</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">			v2.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//四种遍历方式性能比较</span></span><br><span class="line">    <span class="comment">//for-each ≈ Enumeration遍历 &gt; 迭代器遍历 &gt; 随机索引值遍历</span></span><br><span class="line">		traverseByIterator(v2);</span><br><span class="line">		traverseByIndex(v2);</span><br><span class="line">		traverseByFor(v2);</span><br><span class="line">		traverseByEnumeration(v2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIterator</span><span class="params">(Vector&lt;Integer&gt; v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============迭代器遍历=============="</span>);</span><br><span class="line">		Iterator&lt;Integer&gt; iter1 = v.iterator();</span><br><span class="line">		<span class="keyword">while</span> (iter1.hasNext()) &#123;</span><br><span class="line">			iter1.next();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">		<span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">		System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIndex</span><span class="params">(Vector&lt;Integer&gt; v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============随机索引值遍历=============="</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">			v.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">		<span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">		System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByFor</span><span class="params">(Vector&lt;Integer&gt; v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>);</span><br><span class="line">		<span class="keyword">for</span> (Integer item : v) &#123;</span><br><span class="line">			;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">		<span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">		System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByEnumeration</span><span class="params">(Vector&lt;Integer&gt; v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============Enumeration遍历=============="</span>);</span><br><span class="line">		<span class="keyword">for</span> (Enumeration&lt;Integer&gt; enu = v.elements(); enu.hasMoreElements();) &#123;</span><br><span class="line">			enu.nextElement();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">		<span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">		System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h3><ul>
<li><p>集合性质</p>
<ul>
<li><p>确定性：对任意对象都能判定其是否属于某一个集合</p>
</li>
<li><p>互异性：集合内每个元素都是无差异的，注意是内容差异</p>
</li>
<li><p>无序性：集合内的顺序无关</p>
</li>
</ul>
</li>
<li><p>List主要实现：<strong>HashSet</strong> （基于散列函数的集合，无序，不支持同步）、<strong>TreeSet</strong> (基于树结构的集合，可排序的，不支持同步)、<strong>LinkedHashSet</strong>(基于散列函数和双向链表的集合，可排序的，不支持同步)。</p>
<ol>
<li><p><strong>HashSet</strong></p>
<ul>
<li><p><strong>基于HashMap实现的，可以容纳null元素, 不支持同步</strong></p>
<p>• <strong>Set s = Collections.synchronizedSet(new HashSet(…));</strong></p>
</li>
<li><p><strong>add 添加一个元素</strong></p>
</li>
<li><p><strong>clear 清除整个HashSet</strong></p>
</li>
<li><p><strong>contains 判定是否包含一个元素</strong></p>
</li>
<li><p><strong>remove 删除一个元素 size 大小</strong></p>
</li>
<li><p><strong>retainAll 计算两个集合交集</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">		hs.add(<span class="keyword">null</span>);</span><br><span class="line">		hs.add(<span class="number">1000</span>);</span><br><span class="line">		hs.add(<span class="number">20</span>);</span><br><span class="line">		hs.add(<span class="number">3</span>);</span><br><span class="line">		hs.add(<span class="number">40000</span>);</span><br><span class="line">		hs.add(<span class="number">5000000</span>);</span><br><span class="line">		hs.add(<span class="number">3</span>);                      <span class="comment">//3 重复</span></span><br><span class="line">		hs.add(<span class="keyword">null</span>);                   <span class="comment">//null重复</span></span><br><span class="line">		System.out.println(hs.size());  <span class="comment">//6</span></span><br><span class="line">		<span class="keyword">if</span>(!hs.contains(<span class="number">6</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			hs.add(<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(hs.size());  <span class="comment">//7</span></span><br><span class="line">		hs.remove(<span class="number">4</span>);</span><br><span class="line">		System.out.println(hs.size());  <span class="comment">//6</span></span><br><span class="line">		<span class="comment">//hs.clear();</span></span><br><span class="line">		<span class="comment">//System.out.println(hs.size());  //0</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(Integer item : hs)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	System.out.println(item);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    System.out.println(<span class="string">"============测试集合交集=============="</span>);</span><br><span class="line">	    </span><br><span class="line">	    HashSet&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">	    HashSet&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        set1.add(<span class="string">"a"</span>);</span><br><span class="line">        set1.add(<span class="string">"b"</span>);</span><br><span class="line">        set1.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">        set2.add(<span class="string">"c"</span>);</span><br><span class="line">        set2.add(<span class="string">"d"</span>);</span><br><span class="line">        set2.add(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交集</span></span><br><span class="line">        set1.retainAll(set2);</span><br><span class="line">        System.out.println(<span class="string">"交集是 "</span>+set1);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"============测试多种遍历方法速度=============="</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;Integer&gt; hs2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)	&#123;</span><br><span class="line">			hs2.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		traverseByIterator(hs2);</span><br><span class="line">		traverseByFor(hs2);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIterator</span><span class="params">(HashSet&lt;Integer&gt; hs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============迭代器遍历=============="</span>); </span><br><span class="line">	    Iterator&lt;Integer&gt; iter1 = hs.iterator();  </span><br><span class="line">	    <span class="keyword">while</span>(iter1.hasNext())&#123;  </span><br><span class="line">	        iter1.next();  </span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByFor</span><span class="params">(HashSet&lt;Integer&gt; hs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(Integer item : hs)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LinkedHashSetTest</strong></p>
<ul>
<li><p><strong>继承HashSet，也是基于HashMap实现的，可以容纳null元素</strong></p>
</li>
<li><p><strong>不支持同步</strong></p>
<p>• <strong>Set s = Collections.synchronizedSet(new LinkedHashSet(…));</strong></p>
</li>
<li><p><strong>方法和HashSet基本一致</strong></p>
<p>• <strong>add, clear, contains, remove, size</strong></p>
</li>
<li><p><strong>通过一个双向链表维护插入顺序</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LinkedHashSet&lt;Integer&gt; lhs = <span class="keyword">new</span> LinkedHashSet&lt;Integer&gt;();</span><br><span class="line">		lhs.add(<span class="keyword">null</span>);</span><br><span class="line">		lhs.add(<span class="number">1000</span>);</span><br><span class="line">		lhs.add(<span class="number">20</span>);</span><br><span class="line">		lhs.add(<span class="number">3</span>);</span><br><span class="line">		lhs.add(<span class="number">40000</span>);</span><br><span class="line">		lhs.add(<span class="number">5000000</span>);</span><br><span class="line">		lhs.add(<span class="number">3</span>);                      <span class="comment">//3 重复</span></span><br><span class="line">		lhs.add(<span class="keyword">null</span>);                   <span class="comment">//null 重复</span></span><br><span class="line">		System.out.println(lhs.size());  <span class="comment">//6</span></span><br><span class="line">		<span class="keyword">if</span>(!lhs.contains(<span class="number">6</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			lhs.add(<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(lhs.size());  <span class="comment">//7</span></span><br><span class="line">		lhs.remove(<span class="number">4</span>);</span><br><span class="line">		System.out.println(lhs.size());  <span class="comment">//6</span></span><br><span class="line">		<span class="comment">//lhs.clear();</span></span><br><span class="line">		<span class="comment">//System.out.println(lhs.size());  //0</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(Integer item : lhs)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	System.out.println(item);</span><br><span class="line">	    &#125;</span><br><span class="line">		</span><br><span class="line">		LinkedHashSet&lt;Integer&gt; lhs2 = <span class="keyword">new</span> LinkedHashSet&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			lhs2.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		traverseByIterator(lhs2);</span><br><span class="line">		traverseByFor(lhs2);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIterator</span><span class="params">(LinkedHashSet&lt;Integer&gt; hs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============迭代器遍历=============="</span>); </span><br><span class="line">	    Iterator&lt;Integer&gt; iter1 = hs.iterator();  </span><br><span class="line">	    <span class="keyword">while</span>(iter1.hasNext())&#123;  </span><br><span class="line">	        iter1.next();  </span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByFor</span><span class="params">(LinkedHashSet&lt;Integer&gt; hs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(Integer item : hs)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TreeSet</strong></p>
<ul>
<li><p><strong>基于TreeMap实现的，<font color ="ff0000">不可以容纳null元素</font>，不支持同步</strong></p>
<p>• <strong>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(…));</strong></p>
</li>
<li><p><strong>add 添加一个元素</strong></p>
</li>
<li><p><strong>clear 清除整个TreeSet</strong></p>
</li>
<li><p><strong>contains 判定是否包含一个元素</strong></p>
</li>
<li><p><strong>remove 删除一个元素 size 大小</strong></p>
</li>
<li><p><strong>根据compareTo方法或指定Comparator排序</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">		<span class="comment">// ts.add(null);  错误，不支持null</span></span><br><span class="line">		ts.add(<span class="number">1000</span>);</span><br><span class="line">		ts.add(<span class="number">20</span>);</span><br><span class="line">		ts.add(<span class="number">3</span>);</span><br><span class="line">		ts.add(<span class="number">40000</span>);</span><br><span class="line">		ts.add(<span class="number">5000000</span>);</span><br><span class="line">		ts.add(<span class="number">3</span>);                      <span class="comment">//3 重复</span></span><br><span class="line">		System.out.println(ts.size());  <span class="comment">//5</span></span><br><span class="line">		<span class="keyword">if</span>(!ts.contains(<span class="number">6</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			ts.add(<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(ts.size());  <span class="comment">//6</span></span><br><span class="line">		ts.remove(<span class="number">4</span>);</span><br><span class="line">		System.out.println(ts.size());  <span class="comment">//5</span></span><br><span class="line">		<span class="comment">//lhs.clear();</span></span><br><span class="line">		<span class="comment">//System.out.println(lhs.size());  //0</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(Integer item : ts)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	System.out.println(item);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">		TreeSet&lt;Integer&gt; ts2 = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ts2.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		traverseByIterator(ts2);</span><br><span class="line">		traverseByFor(ts2);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByIterator</span><span class="params">(TreeSet&lt;Integer&gt; hs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============迭代器遍历=============="</span>); </span><br><span class="line">	    Iterator&lt;Integer&gt; iter1 = hs.iterator();  </span><br><span class="line">	    <span class="keyword">while</span>(iter1.hasNext())&#123;  </span><br><span class="line">	        iter1.next();  </span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traverseByFor</span><span class="params">(TreeSet&lt;Integer&gt; hs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"============for循环遍历=============="</span>); </span><br><span class="line">	    <span class="keyword">for</span>(Integer item : hs)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">	    <span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">	    System.out.println(duration + <span class="string">"纳秒"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>上述三种方法比较</strong></p>
<p>• <strong>HashSet是无序输出的, LinkedHashSet是按照插入的顺序进行遍历输出, TreeSet是按照所存储的对象大小升序输出</strong></p>
<p>• <strong>HashSet, LinkedHashSet, TreeSet的元素都只能是对象</strong></p>
<p>• <strong>HashSet和LinkedHashSet判定元素重复的原则</strong></p>
<p>​    –<strong>判定两个元素的hashCode返回值是否相同，若不同，返回false</strong></p>
<p>​    –<strong>若两者hashCode相同，判定equals方法，若不同，返回false；否则</strong></p>
<p>​    <strong>返回true。</strong> </p>
<p>​    –<strong>hashCode和equals方法是所有类都有的，因为Object类有</strong></p>
<p>• <strong>TreeSet判定元素重复的原则</strong></p>
<p>​    –<strong><font color ="ff0000">需要元素继承自Comparable接口</font></strong></p>
<p>​    –<strong>比较两个元素的compareTo方法</strong></p>
</li>
</ol>
</li>
</ul>
<h3 id="JCF中的工具类"><a href="#JCF中的工具类" class="headerlink" title="JCF中的工具类"></a>JCF中的工具类</h3><ul>
<li><p><strong>不存储数据，而是在数据容器上，实现高效操作</strong></p>
<ul>
<li><p>排序</p>
</li>
<li><p>搜索</p>
</li>
</ul>
</li>
<li><p><strong>Arrays类</strong>：处理对象是数组</p>
<p>–<strong>排序：对数组排序, sort/parallelSort</strong></p>
<p>–<strong>查找：从数组中查找一个元素, binarySearch</strong> </p>
<p>–<strong>批量拷贝：从源数组批量复制元素到目标数组, copyO。</strong> </p>
<p>–<strong>批量赋值：对数组进行批量赋值, fill</strong> </p>
<p>–<strong>等价性比较：判定两个数组内容是否相同, equals</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		testSort();</span><br><span class="line">		testSearch();</span><br><span class="line">		testCopy();</span><br><span class="line">		testFill();</span><br><span class="line">		testEquality();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Random r = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)	&#123;</span><br><span class="line">			a[i] = r.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"===============测试排序================"</span>);</span><br><span class="line">		System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)	&#123;</span><br><span class="line">			System.out.print(a[i] + <span class="string">","</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">		Arrays.sort(a);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)	&#123;</span><br><span class="line">			System.out.print(a[i] + <span class="string">","</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Random r = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] = r.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		a[a.length-<span class="number">1</span>] = <span class="number">10000</span>;</span><br><span class="line">		System.out.println(<span class="string">"===========测试查找============"</span>);</span><br><span class="line">		System.out.println(<span class="string">"10000 的位置是"</span> + Arrays.binarySearch(a, <span class="number">10000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Random r = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] = r.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">"===========测试拷贝前五个元素============"</span>);</span><br><span class="line">		System.out.print(<span class="string">"源数组："</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(a[i] + <span class="string">","</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.print(<span class="string">"目标数组："</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(b[i] + <span class="string">","</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		Arrays.fill(a, <span class="number">100</span>);</span><br><span class="line">		Arrays.fill(a, <span class="number">2</span>, <span class="number">8</span>, <span class="number">200</span>);</span><br><span class="line">		System.out.println(<span class="string">"===========测试批量赋值============"</span>);</span><br><span class="line">		System.out.print(<span class="string">"数组赋值后："</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(a[i] + <span class="string">","</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEquality</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		Arrays.fill(a, <span class="number">100</span>);</span><br><span class="line">		<span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		Arrays.fill(b, <span class="number">100</span>);		</span><br><span class="line">		System.out.println(Arrays.equals(a, b));</span><br><span class="line">		b[<span class="number">9</span>] = <span class="number">200</span>;</span><br><span class="line">		System.out.println(Arrays.equals(a, b));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Collections类</strong>：处理对象是Collection以及其子类</p>
<p>–<strong>排序：对List进行排序，sort。</strong> </p>
<p>–<strong>搜索：从List中搜索元素，binarySearch</strong></p>
<p>–<strong>批量赋值：对List批量赋值，fill。</strong> </p>
<p>–<strong>最大、最小：查找集合中最大/小值，max，min</strong></p>
<p>–<strong>反序：将List 反序排列，reverse</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">19</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 检索</span></span><br><span class="line">        System.out.println(<span class="string">"元素所在的索引值是："</span> + Collections.binarySearch(list, <span class="number">12</span>));</span><br><span class="line">        <span class="comment">//最大最小</span></span><br><span class="line">        System.out.println(<span class="string">"最大值："</span> + Collections.max(list));</span><br><span class="line">        System.out.println(<span class="string">"最小值："</span> + Collections.min(list));</span><br><span class="line">        Collections.reverse(list); <span class="comment">//翻转不需要用到排序</span></span><br><span class="line">         </span><br><span class="line">        Collections.fill(list, <span class="number">100</span>); <span class="comment">//全部赋值为100</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象比较</strong></p>
<p>• <strong>对象实现Comparable接口</strong>（需要修改对象类）</p>
<p>​    –<strong>compareTo方法</strong></p>
<p>​        • &gt; 返回1， ==返回0，&lt;返回-1 </p>
<p>​    –Arrays和Collections在进行对象sort时，自动调用该方法</p>
<p>• <strong>新建Comparator</strong>（适用于对象类不可更改的情况）</p>
<p>​    –<strong>compare方法</strong></p>
<p>​        • &gt; 返回1， ==返回0，&lt;返回-1 </p>
<p>​    –Comparator比较器将作为参数提交给工具类的sort方法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础整理</title>
    <url>/2020/08/06/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要是总结HTML的基础内容，方便日后查阅。</p>
<a id="more"></a>
<h2 id="Web概述"><a href="#Web概述" class="headerlink" title="Web概述"></a>Web概述</h2><h3 id="1-浏览器内核"><a href="#1-浏览器内核" class="headerlink" title="1 浏览器内核"></a>1 浏览器内核</h3><ul>
<li>JS引擎</li>
<li>渲染引擎<ul>
<li>Trident（IE内核）；EdgeHTML（Edge内核）</li>
<li>Gecko（Firefox内核）</li>
<li>webkit（Safari内核）</li>
<li>Blink（Chrome内核）</li>
</ul>
</li>
</ul>
<h3 id="2-Web标准"><a href="#2-Web标准" class="headerlink" title="2 Web标准"></a>2 Web标准</h3><ul>
<li>结构标准：用于对网页元素进行整理和分类，主要包括XML和XHTML两部分，即.html。</li>
<li>样式标准：用于设置网页元素的外观样式，主要指CSS，即.css。</li>
<li>行为标准：指网页模型的定义及交互的编写，主要包括DOM和ECMAScrpit两部分，即.js。</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="1-HTML基本格式"><a href="#1-HTML基本格式" class="headerlink" title="1 HTML基本格式"></a>1 HTML基本格式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-WebStorm常用快捷键"><a href="#2-WebStorm常用快捷键" class="headerlink" title="2 WebStorm常用快捷键"></a>2 WebStorm常用快捷键</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&gt;：下一个子标签</span></span><br><span class="line"><span class="comment">*：多少个标签</span></span><br><span class="line"><span class="comment">$：标签的名称序号</span></span><br><span class="line"><span class="comment">&#123;&#125;:标签的内容</span></span><br><span class="line"><span class="comment">[]:标签的引用属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--输入：h1,按tab键--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--输入：div#abc,按Tab键--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"abc"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--输入：div.abc,按Tab键--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"abc"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--输入  ul&gt;li*5&gt;a[href=#]&#123;我是第$个&#125; 再按tab键--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>我是第1个<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>我是第2个<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>我是第3个<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>我是第4个<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>我是第5个<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--输入 li*3&gt;div.img&gt;img[src='images/$.jpg'] 再按tab键--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/2.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--快速生成for循环--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">/* for循环：输入itar,再点击tab键*/</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> obj = array[i]; </span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--div#tab1+div#tab2--&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入  link   加tab键--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--引入css   link:css   加tab键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/mycss.css"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--引入js    script:src  加tab键--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--html中插入js   script  加tab键--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--input:button 加tab键--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--form:get--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--form:post--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-HTML常用标签"><a href="#3-HTML常用标签" class="headerlink" title="3 HTML常用标签"></a>3 HTML常用标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span>水平分割线标签</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span>换行标签，只显示一行</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>段落标签</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span>加粗标签</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span>斜体标签</span><br><span class="line"><span class="symbol">&amp;nbsp;</span>特殊符号标签</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"path"</span> <span class="attr">alt</span>=<span class="string">"text"</span> <span class="attr">title</span>=<span class="string">"text"</span> <span class="attr">width</span>=<span class="string">"x"</span> <span class="attr">height</span>=<span class="string">"y"</span>&gt;</span></span><br><span class="line">图片路径 图片丢失提醒信息 鼠标悬停显示信息 宽度 高度</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"path"</span> <span class="attr">target</span>=<span class="string">"目标窗口位置"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">target常用属性：_blank:在新标签中打开 _self:在当前页面打开</span><br><span class="line"><span class="comment">&lt;!--锚链接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"top"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#TOP"</span>&gt;</span>BACK TO TOP<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">设置a标签name属性，通过href指定跳转</span><br><span class="line"><span class="comment">&lt;!--列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>无序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span>有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>自定义列表</span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span>列表名称</span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span>列表内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表格--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"4"</span>&gt;</span>1-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--列 colspan跨列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--列 rowspan跨行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--音视频 controls：加载控件显示视频 autoplay：自动播放 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"path"</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--iframe内联框架--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">"flag"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">引用页面地址 框架标志名 边界属性</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"path"</span> <span class="attr">target</span>=<span class="string">"flag"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表单</span></span><br><span class="line"><span class="comment">action:表单提交的位置，可以是网站，也可以是一个请求处理地址</span></span><br><span class="line"><span class="comment">method:包含get和post两种方式，前者高效但不安全，后者使用场景更多</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"path"</span> <span class="attr">method</span>=<span class="string">"get/post"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--文本输入框 input</span></span><br><span class="line"><span class="comment">		type:通过type属性自动适应方式，可取text表示文本输入，password表示密码输入，submit表示提交，reset表示重置</span></span><br><span class="line"><span class="comment">		value:表示元素默认显示的初始值，type为选择框时(radio/checkbox)必须为其指定初始值</span></span><br><span class="line"><span class="comment">		checked:当type为radio或checkbox时，表示是否默认选中</span></span><br><span class="line"><span class="comment">		name:表示组，也表示该标签的属性，在选择框时需要将name属性值置为相同</span></span><br><span class="line"><span class="comment">		初级验证:placeholder-默认填充信息;required-非空判断;pattern-正则表达式</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"values"</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">tpye</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">name</span>=<span class="string">"gender"</span>/&gt;</span>男</span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">tpye</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"female"</span> <span class="attr">name</span>=<span class="string">"gender"</span>/&gt;</span>女</span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span>  <span class="attr">name</span>=<span class="string">"files"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"上传文件"</span> <span class="attr">name</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--下拉列表框--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文本域--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-网页基本页面结构分析"><a href="#4-网页基本页面结构分析" class="headerlink" title="4 网页基本页面结构分析"></a>4 网页基本页面结构分析</h3><table>
<thead>
<tr>
<th>元素名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>标记头部区域的内容</td>
</tr>
<tr>
<td>footer</td>
<td>标记脚步区域的内容</td>
</tr>
<tr>
<td>section</td>
<td>Web页面中的一块独立区域</td>
</tr>
<tr>
<td>artical</td>
<td>独立的文章内容</td>
</tr>
<tr>
<td>aside</td>
<td>相关内容或应用（常用于侧边栏）</td>
</tr>
<tr>
<td>nav</td>
<td>导航类辅助内容</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解与反射</title>
    <url>/2020/07/30/Java%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要是总结Java注解与反射的相关知识，加深自己对Java类动态语言的理解，同时为日后学习Spring打下基础。</p>
<a id="more"></a>

<h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ul>
<li><strong>Annotation的作用</strong><ul>
<li>不是程序本身，但是可以对程序作出解释。</li>
<li>可以被其他程序（比如：编译器等）读取。</li>
</ul>
</li>
<li><strong>Annotation的格式：</strong><ul>
<li>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings(value=”unchecked”)。</li>
</ul>
</li>
<li><strong>Annotation使用范围：</strong><ul>
<li>附加在package、class、method、field等上面，相当于给他们添加了额外的辅助信息，然后通过反射机制编程实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul>
<li><p><strong>Override：</strong></p>
<p>定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</p>
</li>
<li><p><strong>Deprecated：</strong></p>
<p>定义在java.lang.Deprecated中，此注释可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者有更好的选择。</p>
</li>
<li><p><strong>SuppressWarnings：</strong></p>
<p>定义在java.lang.SuppressWarnings中，用来抑制编译时警告信息，与前两个注释不同，此注解需要添加一个参数才可正常使用：</p>
<p>➢SuppressWarnings(“all”)</p>
<p>➢SuppressWarnings(“unchecked”)</p>
<p>➢SuppressWarnings(value={“deprecation”,”unchecked”})</p>
<p>➢……</p>
</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li><p>元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotaion类型作说明。</p>
</li>
<li><p>这些类型和他们所支持的类在java.lang.annotation包可以找到:</p>
<p>➢<strong>@Target</strong>：用于描述注解的使用范围（即被描述的注解可以用在什么地方）</p>
<p>➢<strong>@Retention</strong>:表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）。</p>
<p>➢<strong>@Document</strong>:说明该注解将被包含在javadoc中。</p>
<p>➢<strong>@Inherited</strong>:说明子类可以继承父类中的该注解。</p>
</li>
</ul>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul>
<li><p>使用<strong>@interface</strong>自定义注解，格式：<strong>public @interface 注解名{定义内容}</strong>。</p>
</li>
<li><p>自定义注解内部的参数格式：<strong><font color ="ff0000">参数类型+参数名()</font></strong>；若只有一个参数成员，参数名默认为<strong>value</strong>。</p>
</li>
<li><p>注解的元素必须要有值，我们定义注解元素时，一般默认使用空字符串，0作为默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注解可以显式赋值，如果没有默认值，则必须赋值</span></span><br><span class="line"><span class="meta">@myAnnotation</span>(id = <span class="number">3</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@myAnnotation</span>(id = <span class="number">5</span>,school = &#123;<span class="string">"THU"</span>,<span class="string">"CMU"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> myAnnotation&#123;</span><br><span class="line">    <span class="comment">//注解的参数：参数类型+参数名()</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    String[] school() <span class="keyword">default</span> &#123;<span class="string">"HDU"</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><ul>
<li><p><strong>Reflection</strong>是Java被视为动态语言的关键，反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
</li>
<li><p>Java在加载完类之后，在堆内存的方法区中就产生了一个<strong><font color ="ff0000">Class类型</font></strong>的对象（<strong><font color ="ff0000">一个类只有一个Class对象</font></strong>），这个对象就包含了完整的类的结构信息。我们通过这个对象可以看到类的结构，这种过程称为反射。</p>
<ul>
<li>正常方式：引入需要的“包类”名称➜通过new实例化➜取得实例化对象</li>
<li>反射方式：实例化对象➜<strong>getClass()方法</strong>➜取得完整的“包类”名称</li>
</ul>
</li>
<li><p>反射相关的API</p>
<ul>
<li><p>java.lang.Class：代表一个类</p>
</li>
<li><p>java.lang.reflect.Method：代表类的方法</p>
</li>
<li><p>java.lang.reflect.Field：代表类的成员变量</p>
</li>
<li><p>java.lang.reflect.Constructor：代表类的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//通过反射获得类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">"JavaDoc.User"</span>);</span><br><span class="line">        Class&lt;?&gt; c2 = Class.forName(<span class="string">"JavaDoc.User"</span>);</span><br><span class="line">        Class&lt;?&gt; c3 = Class.forName(<span class="string">"JavaDoc.User"</span>);</span><br><span class="line">        <span class="comment">//一个类在内存中只有一个Class对象</span></span><br><span class="line">        <span class="comment">//一个类被加载后，类的整个结构都会被封装在Class对象中</span></span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实体类 pojo ,Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">//输出结果：hashCode相同</span></span><br><span class="line"><span class="number">1846274136</span></span><br><span class="line"><span class="number">1846274136</span></span><br><span class="line"><span class="number">1846274136</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="获得Class类的方式"><a href="#获得Class类的方式" class="headerlink" title="获得Class类的方式"></a>获得Class类的方式</h3><ul>
<li><p>若已知具体的类，通过类的<strong>class属性</strong>获取。</p>
</li>
<li><p>若已知某个类的实例化对象，调用该实例的<strong>getClass()方法</strong>获取Class对象。</p>
</li>
<li><p>若已知一个类的全类名，且该类在类路径下，可以通过Class类的<strong>静态方法forName()</strong>方法获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test02</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//通过forName获得</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"JavaDoc.Student"</span>);</span><br><span class="line">        <span class="comment">//通过对象获得</span></span><br><span class="line">        Class c2 = student.getClass();</span><br><span class="line">        <span class="comment">//通过类名.class获得</span></span><br><span class="line">        Class c3 = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">      </span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">        <span class="comment">//获得父类类型</span></span><br><span class="line">        System.out.println(c1.getSuperclass().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实体类 pojo ,Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><table>
<thead>
<tr>
<th>Java内存区域</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>堆</td>
<td>存放new的对象和数组，可以被所有的线程共享，不会存放别的对象引用</td>
</tr>
<tr>
<td>栈</td>
<td>存放基本类型变量（包含具体数值）和引用对象的变量（包含具体地址）</td>
</tr>
<tr>
<td>方法区</td>
<td>可以被所有线程共享，包含了所有class和static变量</td>
</tr>
</tbody></table>
<p>这里只是浅显列出，详细分析需要参考Java的JVM。</p>
<h3 id="Class类初始化"><a href="#Class类初始化" class="headerlink" title="Class类初始化"></a>Class类初始化</h3><ul>
<li><p><strong>类的主动引用一定会发生类的初始化</strong></p>
<ul>
<li>当虚拟机启动时，先初始化main方法所在的类。</li>
<li>调用类的静态成员（除了final常量）和静态方法会发生初始化。</li>
<li>使用java.lang.reflect包反射调用会发生初始化。</li>
</ul>
</li>
<li><p><strong>类的被动引用不会发生类的初始化</strong></p>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如当通过子类引用父类的静态变量，不会导致子类初始化。</li>
<li>通过数组定义类的引用，不会触发此类的初始化。</li>
<li>引用常量不会触发此类的初始化。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test03</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Main类被加载"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//主动引用</span></span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">      	<span class="comment">//final不会初始化父类和子类</span></span><br><span class="line">        System.out.println(Son.M);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类被加载"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类被加载"</span>);</span><br><span class="line">        m = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Main类被加载</span><br><span class="line">父类被加载</span><br><span class="line">子类被加载</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器作用是用来把类装载进内存，JVM规范定义了如下类型的类加载器：</p>
<ul>
<li><p><strong>系统类加载器：</strong></p>
<p>负责java -classpath或- D，导入java.class.path所指定的目录下的类与jar包装入工作，是最常用的加载器。</p>
</li>
<li><p><strong>扩展类加载器：</strong></p>
<p>负责jre/lib/ext目录下的jar包装入工作库。</p>
</li>
<li><p><strong>引导类加载器：</strong></p>
<p>采取C++编写，是JVM自带的类加载器，负责Java平台的核心库，用来装载核心类库，无法直接获取。</p>
</li>
<li><p><strong>类加载器采取双亲委派机制，自底向上检查类是否已经装载，自顶向下尝试加载类。</strong></p>
<p>自定义类加载器⇨System Classloader⇨Extension Classloader⇨Bootstrap Classloader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test04</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">        <span class="comment">//获取系统类加载器的父类加载器 --&gt; 扩展类加载器</span></span><br><span class="line">        ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器 --&gt; 根加载器（c/c++）</span></span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line">        <span class="comment">//获取可加载的系统类加载器</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="类的运行时结构"><a href="#类的运行时结构" class="headerlink" title="类的运行时结构"></a>类的运行时结构</h3><ul>
<li><strong>getName()</strong></li>
<li><strong>getFields()</strong></li>
<li><strong>getMethods()</strong></li>
<li><strong>getConstructors()</strong></li>
<li><strong>……</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test05</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">"JavaDoc.User"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getFields只能获取public类型信息</span></span><br><span class="line">        System.out.println(<span class="string">"===getFields===="</span>);</span><br><span class="line">        Field[] field = c1.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field1 : field) &#123;</span><br><span class="line">            System.out.println(field1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredFields可获取所有信息</span></span><br><span class="line">        System.out.println(<span class="string">"===getDeclaredFields===="</span>);</span><br><span class="line">        field = c1.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field1 : field) &#123;</span><br><span class="line">            System.out.println(field1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">===getFields====</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> JavaDoc.User.score</span><br><span class="line">===getDeclaredFields====</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> JavaDoc.User.score</span><br><span class="line"><span class="keyword">private</span> java.lang.String JavaDoc.User.name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> JavaDoc.User.id</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> JavaDoc.User.age</span><br></pre></td></tr></table></figure>

<h3 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h3><h4 id="创建类的对象："><a href="#创建类的对象：" class="headerlink" title="创建类的对象："></a>创建类的对象：</h4><p>调用Class对象的<strong>newInstance()</strong>方法</p>
<ul>
<li>类必须有一个无参构造器。</li>
<li>类的构造器访问权限需要足够。</li>
</ul>
<h4 id="创建步骤："><a href="#创建步骤：" class="headerlink" title="创建步骤："></a>创建步骤：</h4><ul>
<li>通过<strong>Class</strong>类中的<strong>getDeclaredConstructor()</strong>取得本类的指定形参类型的构造器。</li>
<li>向构造器的形参中传递一个<strong>对象数组</strong>进去，里面包含了构造器中所需的各个参数。</li>
<li>通过<strong>Constructor</strong>实例化对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test06</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">"JavaDoc.User"</span>);</span><br><span class="line">        <span class="comment">//newInstance默认调用无参构造</span></span><br><span class="line">        User user = (User) c1.newInstance();</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过构造器声明含参构造重新调用newInstance</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = c1.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        User user2 = (User) constructor.newInstance(<span class="string">"zhangsan"</span>, <span class="number">001</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射机制调用User类中的方法</span></span><br><span class="line">        Method setName = c1.getDeclaredMethod(<span class="string">"setId"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        setName.invoke(user,<span class="number">001</span>);</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过关闭程序权限检测，操作程序的私有属性</span></span><br><span class="line">        User user4 = (User) c1.newInstance();</span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(user4,<span class="string">"zhangsan2"</span>);</span><br><span class="line">        System.out.println(user4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test07</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">"JavaDoc.User"</span>);</span><br><span class="line">        <span class="comment">//通过反射获得注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得注解内部value值</span></span><br><span class="line">        Table table = c1.getAnnotation(Table<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(table.value());</span><br><span class="line">        <span class="comment">//获取内部指定字段的注解信息</span></span><br><span class="line">        Field f1 = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        fieldStudent field = f1.getAnnotation(fieldStudent<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(field.columnName());</span><br><span class="line">        System.out.println(field.type());</span><br><span class="line">        System.out.println(field.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Table</span>(value = <span class="string">"db_User"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@fieldStudent</span>(columnName = <span class="string">"db_name"</span>,type = <span class="string">"varchar"</span>,length = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@fieldStudent</span>(columnName = <span class="string">"db_id"</span>,type = <span class="string">"int"</span>,length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@fieldStudent</span>(columnName = <span class="string">"db_age"</span>,type = <span class="string">"int"</span>,length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类名的注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Table&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性的注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> fieldStudent&#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出</span></span><br><span class="line"><span class="meta">@JavaDoc</span>.Table(value=db_User)</span><br><span class="line">db_User</span><br><span class="line">db_name</span><br><span class="line">varchar</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java源码阅读</title>
    <url>/2020/07/18/Java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要是总结如何配置Java源码的阅读环境，可以方便我们更深入的了解Java JDK的相关底层实现逻辑，许多诸如HashMap实现逻辑均可通过本方法调试查阅底层交互。</p>
<a id="more"></a>
<p>看完本篇可以收获：</p>
<ul>
<li>Java源码阅读技巧</li>
<li>HashMap基本逻辑</li>
<li>IDEA调试技巧</li>
</ul>
<h2 id="Java源码环境搭建"><a href="#Java源码环境搭建" class="headerlink" title="Java源码环境搭建"></a>Java源码环境搭建</h2><h3 id="1-获取Java源码"><a href="#1-获取Java源码" class="headerlink" title="1.获取Java源码"></a>1.获取Java源码</h3><p>由于新版Java14的源码不好直接获取，我们就选择最常用的Java1.8的源码，通过官网下载Java1.8即可获得对应相关资源，具体实现步骤如下：</p>
<ol>
<li><p>通过Java 1.8构建新的Java项目</p>
<p><img src="https://s1.ax1x.com/2020/07/18/U29utS.png" alt="U29utS.png"></p>
<p>在新建项目中创建两个项目文件夹source和test，其中source用来存放Java的源码，test用来存放需要阅读的源码，笔者这里选择hashmap作为演示。</p>
</li>
<li><p>配置source环境</p>
<p>在source文件中添加我们下载好的Java 1.8的源码，首先选择IDEA左上角Project Structure(Mac英文状态下快捷键⌘;)，然后选择SDKs便可获取到对应的源码路径。</p>
<p><img src="https://s1.ax1x.com/2020/07/18/U2916s.png" alt="U2916s.png"><br>打开对应路径文件找到src.zip文件解压便可得Java 1.8对应的源码，之后将解压后的文件复制粘贴至我们的项目source路径下：(source源码对应文件下的资源可能略有不同，视个人的JDK版本)</p>
<p><img src="https://s1.ax1x.com/2020/07/18/U29Kfg.png" alt="U29Kfg.png"></p>
</li>
<li><p>创建测试代码</p>
<p><img src="https://s1.ax1x.com/2020/07/18/U29QpQ.png" alt="U29QpQ.png"></p>
<p>在test.hashmap中创建Test类，然后键入如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaDoc.test.hashmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Double&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        hashMap.put(<span class="string">"k1"</span>,<span class="number">0.1</span>);</span><br><span class="line">        hashMap.put(<span class="string">"k2"</span>,<span class="number">0.2</span>);</span><br><span class="line">        hashMap.put(<span class="string">"k3"</span>,<span class="number">0.3</span>);</span><br><span class="line">        hashMap.put(<span class="string">"k4"</span>,<span class="number">0.4</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Map所在行处添加断点调试，这样我们基本的HashMap的源码阅读环境就搭建完成了。</p>
</li>
</ol>
<h3 id="2-IDEA环境配置调整"><a href="#2-IDEA环境配置调整" class="headerlink" title="2.IDEA环境配置调整"></a>2.IDEA环境配置调整</h3><ol>
<li><p>修改heap size</p>
<p>为了保证hashmap基本运行稳定，我们先调整一下heap size，打开Preference——Build,Execution——Compiler，找到Build process heap size选项，调整大小：</p>
<p><img src="https://s1.ax1x.com/2020/07/18/U29nk8.png" alt="U29nk8.png"></p>
</li>
<li><p>解除源码查阅编辑限制</p>
<p>由于Java JDK的源码是受保护的，我们进行调试后无法直接进入源码内部去查看实现逻辑，这时候我们就需要更改Preference——Build,Execution——Stepping，找到Do not step into the classes  选项，去除前面的勾选，这时候我们便可以调试进入源码内部了：</p>
<p><img src="https://s1.ax1x.com/2020/07/18/U293Xn.png" alt="U293Xn.png"></p>
<p>接下来我们需要解除源码的编辑限制，这样我们在调试查看源码的过程中就可以添加一部分自己的注释了，首先打开IDEA左上角Project Structure选择SDKs——Sourcepath,选中下图所示文件后，<br>选择最下角➖符号移除，然后添加我们自己目录JavaDoc/src/JavaDoc/source（路径即为自己所对应项目下的source文件）</p>
<p><img src="https://s1.ax1x.com/2020/07/18/U29Gmq.png" alt="U29Gmq.png"></p>
<p><img src="https://s1.ax1x.com/2020/07/18/U29Y7V.png" alt="U29Y7V.png"></p>
<p>这样我们整体的Java源码的阅读环境就搭建起来了，不仅可以查看JDK源码，甚至可以在源码部分添加自己的理解。</p>
</li>
</ol>
<h2 id="HashMap基本调试"><a href="#HashMap基本调试" class="headerlink" title="HashMap基本调试"></a>HashMap基本调试</h2><h3 id="1-启动断点调试"><a href="#1-启动断点调试" class="headerlink" title="1.启动断点调试"></a>1.启动断点调试</h3><p>选择IDEA右上角对应的debug，静等程序debug完成。</p>
<h3 id="2-观察调试过程"><a href="#2-观察调试过程" class="headerlink" title="2.观察调试过程"></a>2.观察调试过程</h3><p>   <img src="https://s1.ax1x.com/2020/07/18/U29J00.png" alt="U29J00.png"></p>
<p>   <img src="https://s1.ax1x.com/2020/07/18/U29NkT.png" alt="U29NkT.png"><br>调试过程只是简单的HashMap的流程记录，原理部分参看网上诸多关于HashMap的讲解。</p>
<h3 id="3-常用的Java源码学习"><a href="#3-常用的Java源码学习" class="headerlink" title="3.常用的Java源码学习"></a>3.常用的Java源码学习</h3><p>在source中包含了所有的Java  JDK1.8的源码，其中主要实现集中于source——Java下：</p>
<p>   <img src="https://s1.ax1x.com/2020/07/18/U29UtU.png" alt="U29UtU.png"></p>
<p>其中各个组件的大致功能如下：</p>
<table>
<thead>
<tr>
<th>常用组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Java.io</td>
<td>基本阻塞式io控制模型，eg:File,Console…</td>
</tr>
<tr>
<td>Java.lang</td>
<td>基础数据包装类型，eg:annotation,reflect…</td>
</tr>
<tr>
<td>Java.math</td>
<td>特殊数据处理类型，eg:BigInteger…</td>
</tr>
<tr>
<td>Java.net</td>
<td>网络通信模型，eg:Socket…</td>
</tr>
<tr>
<td>Java.nio</td>
<td>非阻塞式io控制模型，eg:Buffer…</td>
</tr>
<tr>
<td>Java.time</td>
<td>JDK1.8新增，时间模型</td>
</tr>
<tr>
<td>Java.util</td>
<td>基本工具，eg:J.U.C(concurrent),hashmap…</td>
</tr>
</tbody></table>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要是对Java源码部分通过IDEA进行调试分析，在调试过程中可以记录JDK底层源码的实现逻辑，加深自己对JDK源码的理解。</p>
<p>可能遇到的问题：</p>
<ul>
<li><p>程序调试窗口无法正常调试：</p>
<p>看看是不是IDEA右上角Edit Configurations选错成main class，需要更改成Test所在类。</p>
</li>
<li><p>Test中HashMap调试一直卡在writing classes：</p>
<p>打开设置File——Preference(Windows下对应Settings)——Build,Execution——Compiler：调整heap size大小至合适范围，一般1800Mbytes足矣。</p>
</li>
<li><p>上述bug均未出现，但仍然无法调试阅读源码：</p>
<p>可能是项目下source对应的文件不规范，建议从官网上下载对应的Java JDk，然后在安装目录中找到src.zip文件解压后将其重新导入到source目录下。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习Splash的使用</title>
    <url>/2020/10/09/Scrapy%E5%AD%A6%E4%B9%A0Splash%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Splash的使用</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2020/09/05/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要是总结MySQL的一些学习笔记，方便日后查阅。</p>
<a id="more"></a>

<h2 id="MySQL基本命令行"><a href="#MySQL基本命令行" class="headerlink" title="MySQL基本命令行"></a>MySQL基本命令行</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--启动MySQL：</span></span><br><span class="line">mysql -u root -p </span><br><span class="line"><span class="comment">--查看所有数据库：</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>; </span><br><span class="line"><span class="comment">--切换数据库 use 数据库名：</span></span><br><span class="line"><span class="keyword">use</span> xxx;</span><br><span class="line"><span class="comment">--查看数据库中所有的表：</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">--显示数据库中所有的表信息：desc 表名</span></span><br><span class="line">desc xxx;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL基本知识"><a href="#MySQL基本知识" class="headerlink" title="MySQL基本知识"></a>MySQL基本知识</h2><h3 id="1-MySQL基本操作"><a href="#1-MySQL基本操作" class="headerlink" title="1.MySQL基本操作"></a>1.MySQL基本操作</h3><p>操作数据库&gt;操作数据库中的表&gt;操作数据库表中的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> xxx</span><br><span class="line"><span class="comment">--删除数据库</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> westos</span><br></pre></td></tr></table></figure>

<h3 id="2-MySQL基本数据类型"><a href="#2-MySQL基本数据类型" class="headerlink" title="2.MySQL基本数据类型"></a>2.MySQL基本数据类型</h3><ul>
<li><p>==数值：==</p>
<p>整数类型：int,tinyint,smallint,mediumint,bigint</p>
<p>浮点数类型：float,double</p>
<p><strong>字符串类型的浮点数：decimal</strong></p>
</li>
<li><p>==字符串：==</p>
<p>char：     长度固定的字符串 0-255</p>
<p><strong>varchar：可变长度字符串：0-65535</strong></p>
<p>tinytext：微型文本：2^8^-1</p>
<p><strong>text：      文本串：2^16^-1</strong></p>
</li>
<li><p>==时间日期：==</p>
<p>date：MM-YY-DD 日期格式</p>
<p>time：HH-MM-SS 时间格式</p>
<p><strong>datetime：MM-YY-DD HH-MM-SS</strong> </p>
<p>timestamp：时间戳：1970-01-01到至今的毫秒数</p>
<p>year：年份</p>
</li>
<li><p>==空值：==null 不用来进行数据计算</p>
</li>
</ul>
<h3 id="3-数据库的字段属性"><a href="#3-数据库的字段属性" class="headerlink" title="3.数据库的字段属性"></a>3.数据库的字段属性</h3><ul>
<li><p>==Unsigned：==</p>
<p>无符号整数，表示该列不可以声明为负数。</p>
</li>
<li><p>==zerofill：==</p>
<p>0填充，表示不足设定位数则前导0填充。</p>
</li>
<li><p>==自增：==</p>
<p>自动在上一条记录默认+1（可以自定义），通常用来设置唯一的主键，且必须是整数类型。</p>
</li>
<li><p>==非空：==</p>
<p>Not Null，需要有默认值，否则报错。如果不设定非空属性，则默认值为null。</p>
</li>
</ul>
<h3 id="4-代码创建数据库表"><a href="#4-代码创建数据库表" class="headerlink" title="4.代码创建数据库表"></a>4.代码创建数据库表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本格式：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="string">`表名`</span> (</span><br><span class="line">  <span class="string">`字段名`</span> 列类型[属性][索引][注释],</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">`字段名`</span> 列类型[属性][索引][注释]   </span><br><span class="line">) [表类型][字符集设定][注释];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模版示例：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`school`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'学号'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'匿名'</span>,</span><br><span class="line">  <span class="string">`pwd`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'123456'</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'男'</span>,</span><br><span class="line">  <span class="string">`birthday`</span> datetime(<span class="number">0</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8mb4 <span class="keyword">COLLATE</span> = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习（二）：模块详解</title>
    <url>/2020/09/27/Scrapy%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Scrapy 框架架构清晰，各个模块之间的耦合度较低，可以方便我们进行模块化修改。本篇则对Scrapy框架各模块深入进行研究，并做了一个整理。</p>
<a id="more"></a>

<h2 id="Selector的用法"><a href="#Selector的用法" class="headerlink" title="Selector的用法"></a>Selector的用法</h2><h3 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h3><p>Selector 是一个可以独立使用的模块。我们可以直接利用 Selector 这个类来构建一个选择器对象，然后调用它的相关方法如 xpath()、css() 等来提取数据。</p>
<p>例如，针对一段 HTML 代码，我们可以用如下方式构建 Selector 对象来提取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector</span><br><span class="line">body = <span class="string">'&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line">selector = Selector(text=body)</span><br><span class="line">title = selector.xpath(<span class="string">'//title/text()'</span>).extract_first()</span><br><span class="line">print(title)</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>我们在这里没有在 Scrapy 框架中运行，而是把 Scrapy 中的 Selector 单独拿出来使用了，构建的时候传入 text 参数，就生成了一个 Selector 选择器对象，然后就可以像前面我们所用的 Scrapy 中的解析方式一样，调用 xpath()、css() 等方法来提取了。</p>
<p>在这里我们查找的是源代码中的 title 中的文本，在 XPath 选择器最后加 text() 方法就可以实现文本的提取了。</p>
<p>以上内容就是 Selector 的直接使用方式。同 Beautiful Soup 等库类似，Selector 其实也是强大的网页解析库。如果方便的话，我们也可以在其他项目中直接使用 Selector 来提取数据。</p>
<h3 id="通过选择器"><a href="#通过选择器" class="headerlink" title="通过选择器"></a>通过选择器</h3><p>接下来，演示的实例都将页面的源码作为分析目标，页面源码如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">'http://example.com/'</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example website<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'images'</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image1.html'</span>&gt;</span>Name: My image 1 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image1_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image2.html'</span>&gt;</span>Name: My image 2 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image2_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image3.html'</span>&gt;</span>Name: My image 3 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image3_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image4.html'</span>&gt;</span>Name: My image 4 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image4_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image5.html'</span>&gt;</span>Name: My image 5 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image5_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进入 Scrapy shell 之后，我们将主要操作 response 这个变量来进行解析。因为我们解析的是 HTML 代码，Selector 将自动使用 HTML 语法来分析。</p>
<p>response 有一个属性 selector，我们调用 response.selector 返回的内容就相当于用 response 的 text 构造了一个 Selector 对象。通过这个 Selector 对象我们可以调用解析方法如 xpath()、css() 等，通过向方法传入 XPath 或 CSS 选择器参数就可以实现信息的提取。</p>
<h3 id="XPath选择器"><a href="#XPath选择器" class="headerlink" title="XPath选择器"></a>XPath选择器</h3><h4 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h4><p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nodename</td>
<td align="left">选取此节点的所有子节点。</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">从根节点选取。</td>
</tr>
<tr>
<td align="left">//</td>
<td align="left">从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">选取当前节点。</td>
</tr>
<tr>
<td align="left">..</td>
<td align="left">选取当前节点的父节点。</td>
</tr>
<tr>
<td align="left">@</td>
<td align="left">选取属性。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p>
<table>
<thead>
<tr>
<th align="left">路径表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bookstore</td>
<td align="left">选取 bookstore 元素的所有子节点。</td>
</tr>
<tr>
<td align="left">/bookstore</td>
<td align="left">选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td>
</tr>
<tr>
<td align="left">bookstore/book</td>
<td align="left">选取属于 bookstore 的子元素的所有 book 元素。</td>
</tr>
<tr>
<td align="left">//book</td>
<td align="left">选取所有 book 子元素，而不管它们在文档中的位置。</td>
</tr>
<tr>
<td align="left">bookstore//book</td>
<td align="left">选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>
</tr>
<tr>
<td align="left">//@lang</td>
<td align="left">选取名为 lang 的所有属性。</td>
</tr>
</tbody></table>
<h4 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a>谓语（Predicates）</h4><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。</p>
<p><strong>实例</strong></p>
<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>
<table>
<thead>
<tr>
<th align="left">路径表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/bookstore/book[1]</td>
<td align="left">选取属于 bookstore 子元素的第一个 book 元素。</td>
</tr>
<tr>
<td align="left">/bookstore/book[last()]</td>
<td align="left">选取属于 bookstore 子元素的最后一个 book 元素。</td>
</tr>
<tr>
<td align="left">/bookstore/book[last()-1]</td>
<td align="left">选取属于 bookstore 子元素的倒数第二个 book 元素。</td>
</tr>
<tr>
<td align="left">/bookstore/book[position()&lt;3]</td>
<td align="left">选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>
</tr>
<tr>
<td align="left">//title[@lang]</td>
<td align="left">选取所有拥有名为 lang 的属性的 title 元素。</td>
</tr>
<tr>
<td align="left">//title[@lang=’eng’]</td>
<td align="left">选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>
</tr>
<tr>
<td align="left">/bookstore/book[price&gt;35.00]</td>
<td align="left">选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
<tr>
<td align="left">/bookstore/book[price&gt;35.00]/title</td>
<td align="left">选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>
</tr>
</tbody></table>
<h4 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h4><p>XPath 通配符可用来选取未知的 XML 元素。</p>
<table>
<thead>
<tr>
<th align="left">通配符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配任何元素节点。</td>
</tr>
<tr>
<td align="left">@*</td>
<td align="left">匹配任何属性节点。</td>
</tr>
<tr>
<td align="left">node()</td>
<td align="left">匹配任何类型的节点。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>
<table>
<thead>
<tr>
<th align="left">路径表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/bookstore/*</td>
<td align="left">选取 bookstore 元素的所有子元素。</td>
</tr>
<tr>
<td align="left">//*</td>
<td align="left">选取文档中的所有元素。</td>
</tr>
<tr>
<td align="left">//title[@*]</td>
<td align="left">选取所有带有属性的 title 元素。</td>
</tr>
</tbody></table>
<h4 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a>选取若干路径</h4><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p>
<p><strong>实例</strong></p>
<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>
<table>
<thead>
<tr>
<th align="left">路径表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">//book/title | //book/price</td>
<td align="left">选取 book 元素的所有 title 和 price 元素。</td>
</tr>
<tr>
<td align="left">//title | //price</td>
<td align="left">选取文档中的所有 title 和 price 元素。</td>
</tr>
<tr>
<td align="left">/bookstore/book/title | //price</td>
<td align="left">选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td>
</tr>
</tbody></table>
<h4 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h4><p>分析如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = response.selector.xpath(<span class="string">'//a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">[&lt;Selector xpath=<span class="string">'//a'</span> data=<span class="string">'&lt;a href="image1.html"&gt;Name: My image 1 &lt;'</span>&gt;,</span><br><span class="line"> &lt;Selector xpath=<span class="string">'//a'</span> data=<span class="string">'&lt;a href="image2.html"&gt;Name: My image 2 &lt;'</span>&gt;,</span><br><span class="line"> &lt;Selector xpath=<span class="string">'//a'</span> data=<span class="string">'&lt;a href="image3.html"&gt;Name: My image 3 &lt;'</span>&gt;,</span><br><span class="line"> &lt;Selector xpath=<span class="string">'//a'</span> data=<span class="string">'&lt;a href="image4.html"&gt;Name: My image 4 &lt;'</span>&gt;,</span><br><span class="line"> &lt;Selector xpath=<span class="string">'//a'</span> data=<span class="string">'&lt;a href="image5.html"&gt;Name: My image 5 &lt;'</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(result)</span><br><span class="line">scrapy.selector.unified.SelectorList</span><br></pre></td></tr></table></figure>

<p>打印结果的形式是 Selector 组成的列表，其实它是 SelectorList 类型，SelectorList 和 Selector 都可以继续调用 xpath() 和 css() 等方法来进一步提取数据。</p>
<p>在上面的例子中，我们提取了 a 节点。接下来，我们尝试继续调用 xpath() 方法来提取 a 节点内包含的 img 节点，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.xpath(<span class="string">'./img'</span>)</span><br><span class="line">[&lt;Selector xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image1_thumb.jpg"&gt;'</span>&gt;,</span><br><span class="line"> &lt;Selector xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image2_thumb.jpg"&gt;'</span>&gt;,</span><br><span class="line"> &lt;Selector xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image3_thumb.jpg"&gt;'</span>&gt;,</span><br><span class="line"> &lt;Selector xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image4_thumb.jpg"&gt;'</span>&gt;,</span><br><span class="line"> &lt;Selector xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image5_thumb.jpg"&gt;'</span>&gt;]</span><br></pre></td></tr></table></figure>

<p>我们获得了 a 节点里面的所有 img 节点，结果为 5。</p>
<p>值得注意的是，选择器的最前方加 .（点），这代表提取元素内部的数据，如果没有加点，则代表从根节点开始提取。此处我们用了./img 的提取方式，则代表从 a 节点里进行提取。如果此处我们用 //img，则还是从 html 节点里进行提取。</p>
<p>我们刚才使用了 response.selector.xpath() 方法对数据进行了提取。Scrapy 提供了两个实用的快捷方法，response.xpath() 和 response.css()，它们二者的功能完全等同于 response.selector.xpath() 和 response.selector.css()。方便起见，后面我们统一直接调用 response 的 xpath() 和 css() 方法进行选择。</p>
<p>现在我们得到的是 SelectorList 类型的变量，该变量是由 Selector 对象组成的列表。我们可以用索引单独取出其中某个 Selector 元素，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result[<span class="number">0</span>]</span><br><span class="line">&lt;Selector xpath=<span class="string">'//a'</span> data=<span class="string">'&lt;a href="image1.html"&gt;Name: My image 1 &lt;'</span>&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以像操作列表一样操作这个 SelectorList。</p>
<p>但是现在获取的内容是 Selector 或者 SelectorList 类型，并不是真正的文本内容。那么具体的内容怎么提取呢？</p>
<p>比如我们现在想提取出 a 节点元素，就可以利用 extract() 方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.extract()</span><br><span class="line">[<span class="string">'&lt;a href="image1.html"&gt;Name: My image 1 &lt;br&gt;&lt;img src="image1_thumb.jpg"&gt;&lt;/a&gt;'</span>, <span class="string">'&lt;a href="image2.html"&gt;Name: My image 2 &lt;br&gt;&lt;img src="image2_thumb.jpg"&gt;&lt;/a&gt;'</span>, <span class="string">'&lt;a href="image3.html"&gt;Name: My image 3 &lt;br&gt;&lt;img src="image3_thumb.jpg"&gt;&lt;/a&gt;'</span>, <span class="string">'&lt;a href="image4.html"&gt;Name: My image 4 &lt;br&gt;&lt;img src="image4_thumb.jpg"&gt;&lt;/a&gt;'</span>, <span class="string">'&lt;a href="image5.html"&gt;Name: My image 5 &lt;br&gt;&lt;img src="image5_thumb.jpg"&gt;&lt;/a&gt;'</span>]</span><br></pre></td></tr></table></figure>

<p>这里使用了 extract() 方法，我们就可以把真实需要的内容获取下来。</p>
<p>我们还可以改写 XPath 表达式，来选取节点的内部文本和属性，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.xpath(<span class="string">'//a/text()'</span>).extract()</span><br><span class="line">[<span class="string">'Name: My image 1 '</span>, <span class="string">'Name: My image 2 '</span>, <span class="string">'Name: My image 3 '</span>, <span class="string">'Name: My image 4 '</span>, <span class="string">'Name: My image 5 '</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.xpath(<span class="string">'//a/@href'</span>).extract()</span><br><span class="line">[<span class="string">'image1.html'</span>, <span class="string">'image2.html'</span>, <span class="string">'image3.html'</span>, <span class="string">'image4.html'</span>, <span class="string">'image5.html'</span>]</span><br></pre></td></tr></table></figure>

<p>我们只需要再加一层 /text() 就可以获取节点的内部文本，或者加一层 /@href 就可以获取节点的 href 属性。其中，@符号后面内容就是要获取的属性名称。</p>
<p>现在我们可以用一个规则把所有符合要求的节点都获取下来，返回的类型是列表类型。</p>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><h2 id="Spider的用法"><a href="#Spider的用法" class="headerlink" title="Spider的用法"></a>Spider的用法</h2><h4 id="Spider运行流程"><a href="#Spider运行流程" class="headerlink" title="Spider运行流程"></a>Spider运行流程</h4><h4 id="Spider类分析"><a href="#Spider类分析" class="headerlink" title="Spider类分析"></a>Spider类分析</h4><h2 id="Middleware的用法"><a href="#Middleware的用法" class="headerlink" title="Middleware的用法"></a>Middleware的用法</h2><h4 id="Downloader-Middleware的用法"><a href="#Downloader-Middleware的用法" class="headerlink" title="Downloader Middleware的用法"></a>Downloader Middleware的用法</h4><h4 id="Spider-Middleware的用法"><a href="#Spider-Middleware的用法" class="headerlink" title="Spider Middleware的用法"></a>Spider Middleware的用法</h4><h2 id="Item-Pipeline的用法"><a href="#Item-Pipeline的用法" class="headerlink" title="Item Pipeline的用法"></a>Item Pipeline的用法</h2>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习（一）：基本架构与项目入门</title>
    <url>/2020/09/25/Scrapy%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Scrapy 是一个基于 Twisted 的异步处理框架，是纯 Python 实现的爬虫框架，其架构清晰，可扩展性极强。本文主要是通过一个简单的爬虫项目，完成一遍 Scrapy 抓取流程。</p>
<a id="more"></a>

<h2 id="Scrapy框架介绍"><a href="#Scrapy框架介绍" class="headerlink" title="Scrapy框架介绍"></a>Scrapy框架介绍</h2><h3 id="1-架构模式"><a href="#1-架构模式" class="headerlink" title="1.架构模式"></a>1.架构模式</h3><p>Scrapy 架构可以分为如下的几个部分：</p>
<ul>
<li><p>Engine，引擎，用来处理整个系统的数据流处理，触发事务，是整个框架的核心。</p>
</li>
<li><p>Item，项目，它定义了爬取结果的数据结构，爬取的数据会被赋值成该对象。</p>
</li>
<li><p>Scheduler， 调度器，用来接受引擎发过来的请求并加入队列中，并在引擎再次请求的时候提供给引擎。</p>
</li>
<li><p>Downloader，下载器，用于下载网页内容，并将网页内容返回给蜘蛛。</p>
</li>
<li><p>Spiders，蜘蛛，其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。</p>
</li>
<li><p>Item Pipeline，项目管道，负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。</p>
</li>
<li><p>Downloader Middlewares，下载器中间件，位于引擎和下载器之间的钩子框架，主要是处理引擎与下载器之间的请求及响应。</p>
</li>
<li><p>Spider Middlewares， 蜘蛛中间件，位于引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛输入的响应和输出的结果及新的请求。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj30d6gdh9j31400t2183.jpg" alt=""></p>
</li>
</ul>
<h3 id="2-数据流"><a href="#2-数据流" class="headerlink" title="2.数据流"></a>2.数据流</h3><p>Scrapy 中的数据流由引擎控制，其过程如下:</p>
<ul>
<li>Engine 首先打开一个网站，找到处理该网站的 Spider 并向该 Spider 请求第一个要爬取的 URL。</li>
<li>Engine 从 Spider 中获取到第一个要爬取的 URL 并通过 Scheduler 以 Request 的形式调度。</li>
<li>Engine 向 Scheduler 请求下一个要爬取的 URL。</li>
<li>Scheduler 返回下一个要爬取的 URL 给 Engine，Engine 将 URL 通过 Downloader Middlewares 转发给 Downloader 下载。</li>
<li>一旦页面下载完毕， Downloader 生成一个该页面的 Response，并将其通过 Downloader Middlewares 发送给 Engine。</li>
<li>Engine 从下载器中接收到 Response 并通过 Spider Middlewares 发送给 Spider 处理。</li>
<li>Spider 处理 Response 并返回爬取到的 Item 及新的 Request 给 Engine。</li>
<li>Engine 将 Spider 返回的 Item 给 Item Pipeline，将新的 Request 给 Scheduler。</li>
<li>重复第二步到最后一步，直到 Scheduler 中没有更多的 Request，Engine 关闭该网站，爬取结束。</li>
</ul>
<p>通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，Scrapy 最大限度地利用了网络带宽，大大提高了数据爬取和处理的效率。</p>
<h3 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3.项目结构"></a>3.项目结构</h3><p>Scrapy 框架和 pyspider 不同，它是通过命令行来创建项目的，代码的编写还是需要 IDE。项目创建之后，项目文件结构如下所示：</p>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">scrapy.cfg</span><br><span class="line">project/</span><br><span class="line">    __init__.py</span><br><span class="line">    items.py</span><br><span class="line">    pipelines.py</span><br><span class="line">    settings.py</span><br><span class="line">    middlewares.py</span><br><span class="line">    spiders/</span><br><span class="line">        __init__.py</span><br><span class="line">        spider1.py</span><br><span class="line">        spider2.py</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</blockquote>
<p>各个文件的功能描述如下：</p>
<ul>
<li>scrapy.cfg：它是 Scrapy 项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。</li>
<li>items.py：它定义 Item 数据结构，所有的 Item 的定义都可以放这里。</li>
<li>pipelines.py：它定义 Item Pipeline 的实现，所有的 Item Pipeline 的实现都可以放这里。</li>
<li>settings.py：它定义项目的全局配置。</li>
<li>middlewares.py：它定义 Spider Middlewares 和 Downloader Middlewares 的实现。</li>
<li>spiders：其内包含一个个 Spider 的实现，每个 Spider 都有一个文件。</li>
</ul>
<h2 id="Scrapy入门"><a href="#Scrapy入门" class="headerlink" title="Scrapy入门"></a>Scrapy入门</h2><h3 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h3><blockquote>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">scrapy startproject projects <span class="comment">//创建项目</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个命令将会创建一个名为 projects 的文件夹，文件夹结构如下所示：</p>
<blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">scrapy.cfg     <span class="comment"># Scrapy 部署时的配置文件</span></span><br><span class="line">projects       <span class="comment"># 项目的模块，引入的时候需要从这里引入</span></span><br><span class="line">    __init__.py    </span><br><span class="line">    <span class="keyword">items</span>.py     <span class="comment"># Items 的定义，定义爬取的数据结构</span></span><br><span class="line">    middlewares.py   <span class="comment"># Middlewares 的定义，定义爬取时的中间件</span></span><br><span class="line">    pipelines.py       <span class="comment"># Pipelines 的定义，定义数据管道</span></span><br><span class="line">    settings.py       <span class="comment"># 配置文件</span></span><br><span class="line">    spiders         <span class="comment"># 放置 Spiders 的文件夹</span></span><br><span class="line">    __init__.py</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-创建Spiders"><a href="#2-创建Spiders" class="headerlink" title="2.创建Spiders"></a>2.创建Spiders</h3><p>Spider 是自己定义的类，Scrapy 用它来从网页里抓取内容，并解析抓取的结果。不过这个类必须继承 Scrapy 提供的 Spider 类 scrapy.Spider，还要定义 Spider 的名称和起始请求，以及怎样处理爬取后的结果的方法。</p>
<p>也可以使用命令行创建一个 Spider。比如要生成 Quotes 这个 Spider，可以执行如下命令：</p>
<blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">cd projects</span><br><span class="line">scrapy genspider quotes <span class="string">http:</span><span class="comment">//quotes.toscrape.com/ </span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>进入刚才创建的 projects 文件夹，然后执行 genspider 命令。第一个参数是 Spider 的名称，第二个参数是网站域名。执行完毕之后，spiders 文件夹中多了一个 quotes.py，它就是刚刚创建的 Spider，内容如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'quotes'</span></span><br><span class="line">    allowed_domains = [<span class="string">'quotes.toscrape.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这里有三个属性 ——name、allowed_domains 和 start_urls，还有一个方法 parse。</p>
<ul>
<li>name，它是每个项目唯一的名字，用来区分不同的 Spider。</li>
<li>allowed_domains，它是允许爬取的域名，如果初始或后续的请求链接不是这个域名下的，则请求链接会被过滤掉。</li>
<li>start_urls，它包含了 Spider 在启动时爬取的 url 列表，初始请求是由它来定义的。</li>
<li>parse，它是 Spider 的一个方法。默认情况下，被调用时 start_urls 里面的链接构成的请求完成下载执行后，返回的响应就会作为唯一的参数传递给这个函数。该方法负责解析返回的响应、提取数据或者进一步生成要处理的请求。</li>
</ul>
<h3 id="3-创建Item"><a href="#3-创建Item" class="headerlink" title="3.创建Item"></a>3.创建Item</h3><p>Item 是保存爬取数据的容器，它的使用方法和字典类似。不过，相比字典，Item 多了额外的保护机制，可以避免拼写错误或者定义字段错误。</p>
<p>创建 Item 需要继承 scrapy.Item 类，并且定义类型为 scrapy.Field 的字段。观察目标网站，我们可以获取到的内容有 text、author、tags。</p>
<p>定义 Item，此时将 items.py 修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuoteItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">  </span><br><span class="line">    text = scrapy.Field()</span><br><span class="line">    author = scrapy.Field()</span><br><span class="line">    tags = scrapy.Field()</span><br></pre></td></tr></table></figure>

<p>这里定义了三个字段，将类的名称修改为 QuoteItem，接下来爬取时我们会使用到这个 Item。</p>
<h3 id="4-解析Response"><a href="#4-解析Response" class="headerlink" title="4.解析Response"></a>4.解析Response</h3><p>前面我们看到，parse() 方法的参数 response 是 start_urls 里面的链接爬取后的结果。所以在 parse() 方法中，我们可以直接对 response 变量包含的内容进行解析，比如浏览请求结果的网页源代码，或者进一步分析源代码内容，或者找出结果中的链接而得到下一个请求。</p>
<p>我们可以看到网页中既有我们想要的结果，又有下一页的链接，这两部分内容我们都要进行处理。</p>
<p>首先看看网页结构，如图 13-2 所示。每一页都有多个 class 为 quote 的区块，每个区块内都包含 text、author、tags。那么我们先找出所有的 quote，然后提取每一个 quote 中的内容。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj31kruen1j30zk0u07co.jpg" alt=""></p>
<p>提取的方式可以是 CSS 选择器或 XPath 选择器。在这里我们使用 CSS 选择器进行选择，parse() 方法的改写如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">  quotes = response.css(<span class="string">'.quote'</span>)</span><br><span class="line">  <span class="keyword">for</span> quote <span class="keyword">in</span> quotes:</span><br><span class="line">    text = quote.css(<span class="string">'.text::text'</span>).extract_first()</span><br><span class="line">    author = quote.css(<span class="string">'.author::text'</span>).extract_first()</span><br><span class="line">    tags = quote.css(<span class="string">'.tags .tag::text'</span>).extract()</span><br></pre></td></tr></table></figure>

<p>这里首先利用选择器选取所有的 quote，并将其赋值为 quotes 变量，然后利用 for 循环对每个 quote 遍历，解析每个 quote 的内容。</p>
<p>对 text 来说，观察到它的 class 为 text，所以可以用.text 选择器来选取，这个结果实际上是整个带有标签的节点，要获取它的正文内容，可以加::text 来获取。这时的结果是长度为 1 的列表，所以还需要用 extract_first() 方法来获取第一个元素。而对于 tags 来说，由于我们要获取所有的标签，所以用 extract() 方法获取整个列表即可。</p>
<h3 id="5-使用Item"><a href="#5-使用Item" class="headerlink" title="5.使用Item"></a>5.使用Item</h3><p>上文定义了 Item，接下来就要使用它了。Item 可以理解为一个字典，不过在声明的时候需要实例化。然后依次用刚才解析的结果赋值 Item 的每一个字段，最后将 Item 返回即可。</p>
<p><strong>quotes.py</strong>的改写如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> projects.items <span class="keyword">import</span> QuoteItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'quotes'</span></span><br><span class="line">    allowed_domains = [<span class="string">'quotes.toscrape.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        quotes = response.css(<span class="string">'.quote'</span>)</span><br><span class="line">        <span class="keyword">for</span> quote <span class="keyword">in</span> quotes:</span><br><span class="line">            item = QuoteItem()</span><br><span class="line">            item[<span class="string">'text'</span>] = quote.css(<span class="string">'.text::text'</span>).extract_first()</span><br><span class="line">            item[<span class="string">'author'</span>] = quote.css(<span class="string">'.author::text'</span>).extract_first()</span><br><span class="line">            item[<span class="string">'tags'</span>] = quote.css(<span class="string">'.tags .tag::text'</span>).extract()</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<p>如此一来，首页的所有内容被解析出来，并被赋值成了一个个 QuoteItem。</p>
<h3 id="6-后续Request请求"><a href="#6-后续Request请求" class="headerlink" title="6.后续Request请求"></a>6.后续Request请求</h3><p>上面的操作实现了从初始页面抓取内容。那么，下一页的内容该如何抓取？这就需要我们从当前页面中找到信息来生成下一个请求，然后在下一个请求的页面里找到信息再构造再下一个请求。这样循环往复迭代，从而实现整站的爬取。</p>
<p>将刚才的页面拉到最底部，发现有一个 Next 按钮，查看一下源代码，可以发现它的链接是 /page/2/，实际上全链接就是：<a href="http://quotes.toscrape.com/page/2，通过这个链接我们就可以构造下一个请求。" target="_blank" rel="noopener">http://quotes.toscrape.com/page/2，通过这个链接我们就可以构造下一个请求。</a></p>
<p>构造请求时需要用到 scrapy.Request。这里我们传递两个参数 ——url 和 callback，这两个参数的说明如下。</p>
<ul>
<li>url：它是请求链接。</li>
<li>callback：它是回调函数。当指定了该回调函数的请求完成之后，获取到响应，引擎会将该响应作为参数传递给这个回调函数。回调函数进行解析或生成下一个请求，回调函数如上文的 parse() 所示。</li>
</ul>
<p>由于 parse() 就是解析 text、author、tags 的方法，而下一页的结构和刚才已经解析的页面结构是一样的，所以我们可以再次使用 parse() 方法来做页面解析。</p>
<p>接下来我们要做的就是利用选择器得到下一页链接并生成请求，在 parse() 方法后追加如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">next = response.css(<span class="string">'.pager .next a::attr(href)'</span>).extract_first()</span><br><span class="line">url = response.urljoin(next)</span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse)</span><br></pre></td></tr></table></figure>

<p>第一句代码首先通过 CSS 选择器获取下一个页面的链接，即要获取 a 超链接中的 href 属性。这里用到了::attr(href) 操作。然后再调用 extract_first() 方法获取内容。</p>
<p>第二句代码调用了 urljoin() 方法，urljoin() 方法可以将相对 URL 构造成一个绝对的 URL。例如，获取到的下一页地址是 /page/2，urljoin() 方法处理后得到的结果就是：<a href="http://quotes.toscrape.com/page/2/。" target="_blank" rel="noopener">http://quotes.toscrape.com/page/2/。</a></p>
<p>第三句代码通过 url 和 callback 变量构造了一个新的请求，回调函数 callback 依然使用 parse() 方法。这个请求完成后，响应会重新经过 parse 方法处理，得到第二页的解析结果，然后生成第二页的下一页，也就是第三页的请求。这样爬虫就进入了一个循环，直到最后一页。</p>
<p>通过几行代码，我们就轻松实现了一个抓取循环，将每个页面的结果抓取下来了。</p>
<p>现在，改写之后的整个 Spider 类如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> projects.items <span class="keyword">import</span> QuoteItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'quotes'</span></span><br><span class="line">    allowed_domains = [<span class="string">'quotes.toscrape.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        quotes = response.css(<span class="string">'.quote'</span>)</span><br><span class="line">        <span class="keyword">for</span> quote <span class="keyword">in</span> quotes:</span><br><span class="line">            item = QuoteItem()</span><br><span class="line">            item[<span class="string">'text'</span>] = quote.css(<span class="string">'.text::text'</span>).extract_first()</span><br><span class="line">            item[<span class="string">'author'</span>] = quote.css(<span class="string">'.author::text'</span>).extract_first()</span><br><span class="line">            item[<span class="string">'tags'</span>] = quote.css(<span class="string">'.tags .tag::text'</span>).extract()</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">       </span><br><span class="line">        next = response.css(<span class="string">'.pager .next a::attr(href)'</span>).extract_first()</span><br><span class="line">        url = response.urljoin(next)</span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse)</span><br></pre></td></tr></table></figure>

<h3 id="7-项目运行"><a href="#7-项目运行" class="headerlink" title="7.项目运行"></a>7.项目运行</h3><p>进入目录，运行如下命令：就可以看到 Scrapy 的运行结果了。</p>
<blockquote>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scrapy crawl quotes</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>具体结果展示如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">➜  projects scrapy crawl quotes   </span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">17</span> [scrapy.utils.log] INFO: Scrapy <span class="number">1.8</span><span class="number">.0</span> started (bot: projects)</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">17</span> [scrapy.utils.log] INFO: Versions: lxml <span class="number">4.5</span><span class="number">.0</span><span class="number">.0</span>, libxml2 <span class="number">2.9</span><span class="number">.9</span>, cssselect <span class="number">1.1</span><span class="number">.0</span>, parsel <span class="number">1.6</span><span class="number">.0</span>, w3lib <span class="number">1.22</span><span class="number">.0</span>, Twisted <span class="number">20.3</span><span class="number">.0</span>, Python <span class="number">3.7</span><span class="number">.6</span> (<span class="keyword">default</span>, Jan  <span class="number">8</span> <span class="number">2020</span>, <span class="number">13</span>:<span class="number">42</span>:<span class="number">34</span>) - [Clang <span class="number">4.0</span><span class="number">.1</span> (tags/RELEASE_401/<span class="keyword">final</span>)], pyOpenSSL <span class="number">19.1</span><span class="number">.0</span> (OpenSSL <span class="number">1.1</span><span class="number">.1</span>d  <span class="number">10</span> Sep <span class="number">2019</span>), cryptography <span class="number">2.8</span>, Platform Darwin<span class="number">-19.6</span><span class="number">.0</span>-x86_64-i386<span class="number">-64</span>bit</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">17</span> [scrapy.crawler] INFO: Overridden settings: &#123;<span class="string">'BOT_NAME'</span>: <span class="string">'projects'</span>, <span class="string">'NEWSPIDER_MODULE'</span>: <span class="string">'projects.spiders'</span>, <span class="string">'ROBOTSTXT_OBEY'</span>: True, <span class="string">'SPIDER_MODULES'</span>: [<span class="string">'projects.spiders'</span>]&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">18</span> [scrapy.extensions.telnet] INFO: Telnet Password: <span class="number">4e7</span>bf07a3653a00e</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">18</span> [scrapy.middleware] INFO: Enabled extensions:</span><br><span class="line">[]</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">18</span> [scrapy.middleware] INFO: Enabled downloader middlewares:</span><br><span class="line">[]</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">18</span> [scrapy.middleware] INFO: Enabled spider middlewares:</span><br><span class="line">[]</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">18</span> [scrapy.middleware] INFO: Enabled item pipelines:</span><br><span class="line">[]</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">18</span> [scrapy.core.engine] INFO: Spider opened</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">18</span> [scrapy.extensions.logstats] INFO: Crawled <span class="number">0</span> pages (at <span class="number">0</span> pages/min), scraped <span class="number">0</span> items (at <span class="number">0</span> items/min)</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">18</span> [scrapy.extensions.telnet] INFO: Telnet console listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6023</span></span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">19</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">404</span>) &lt;GET http:<span class="comment">//quotes.toscrape.com/robots.txt&gt; (referer: None)</span></span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">20</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET http:<span class="comment">//quotes.toscrape.com/&gt; (referer: None)</span></span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">20</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> http:<span class="comment">//quotes.toscrape.com/&gt;</span></span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'Albert Einstein'</span>,</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'change'</span>, <span class="string">'deep-thoughts'</span>, <span class="string">'thinking'</span>, <span class="string">'world'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'“The world as we have created it is a process of our thinking. It '</span></span><br><span class="line">         <span class="string">'cannot be changed without changing our thinking.”'</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">20</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> http:<span class="comment">//quotes.toscrape.com/&gt;</span></span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'J.K. Rowling'</span>,</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'abilities'</span>, <span class="string">'choices'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'“It is our choices, Harry, that show what we truly are, far more '</span></span><br><span class="line">         <span class="string">'than our abilities.”'</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">20</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> http:<span class="comment">//quotes.toscrape.com/&gt;</span></span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'Albert Einstein'</span>,</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'inspirational'</span>, <span class="string">'life'</span>, <span class="string">'live'</span>, <span class="string">'miracle'</span>, <span class="string">'miracles'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'“There are only two ways to live your life. One is as though nothing '</span></span><br><span class="line">         <span class="string">'is a miracle. The other is as though everything is a miracle.”'</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">20</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> http:<span class="comment">//quotes.toscrape.com/&gt;</span></span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'Jane Austen'</span>,</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'aliteracy'</span>, <span class="string">'books'</span>, <span class="string">'classic'</span>, <span class="string">'humor'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'“The person, be it gentleman or lady, who has not pleasure in a good '</span></span><br><span class="line">         <span class="string">'novel, must be intolerably stupid.”'</span>&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**省略部分爬取结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">29</span> [scrapy.core.engine] INFO: Closing spider (finished)</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">29</span> [scrapy.statscollectors] INFO: Dumping Scrapy stats:</span><br><span class="line">&#123;<span class="string">'downloader/request_bytes'</span>: <span class="number">2870</span>,</span><br><span class="line"> <span class="string">'downloader/request_count'</span>: <span class="number">11</span>,</span><br><span class="line"> <span class="string">'downloader/request_method_count/GET'</span>: <span class="number">11</span>,</span><br><span class="line"> <span class="string">'downloader/response_bytes'</span>: <span class="number">24911</span>,</span><br><span class="line"> <span class="string">'downloader/response_count'</span>: <span class="number">11</span>,</span><br><span class="line"> <span class="string">'downloader/response_status_count/200'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'downloader/response_status_count/404'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'item_scraped_count'</span>: <span class="number">100</span>,</span><br><span class="line"> <span class="string">'memusage/max'</span>: <span class="number">49348608</span>,</span><br><span class="line"> <span class="string">'memusage/startup'</span>: <span class="number">49348608</span>,</span><br><span class="line"> <span class="string">'robotstxt/request_count'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'robotstxt/response_count'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'robotstxt/response_status_count/404'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'scheduler/dequeued'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'scheduler/dequeued/memory'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'scheduler/enqueued'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'scheduler/enqueued/memory'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'start_time'</span>: datetime.datetime(<span class="number">2020</span>, <span class="number">9</span>, <span class="number">25</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">123168</span>)&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-09</span><span class="number">-25</span> <span class="number">18</span>:<span class="number">09</span>:<span class="number">29</span> [scrapy.core.engine] INFO: Spider closed (finished)</span><br><span class="line">➜  projects</span><br></pre></td></tr></table></figure>

<p>这里只是部分运行结果，中间一些抓取结果已省略。</p>
<p>首先，Scrapy 输出了当前的版本号以及正在启动的项目名称。接着输出了当前 settings.py 中一些重写后的配置。然后输出了当前所应用的 Middlewares 和 Pipelines。Middlewares 默认是启用的，可以在 settings.py 中修改。Pipelines 默认是空，同样也可以在 settings.py 中配置。后面会对它们进行讲解。</p>
<p>接下来就是输出各个页面的抓取结果了，可以看到爬虫一边解析，一边翻页，直至将所有内容抓取完毕，然后终止。</p>
<p>最后，Scrapy 输出了整个抓取过程的统计信息，如请求的字节数、请求次数、响应次数、完成原因等。</p>
<p>整个 Scrapy 程序成功运行。我们通过非常简单的代码就完成了一个网站内容的爬取，这样相比之前一点点写程序简洁很多。</p>
<h3 id="8-项目保存"><a href="#8-项目保存" class="headerlink" title="8.项目保存"></a>8.项目保存</h3><p>运行完 Scrapy 后，我们只在控制台看到了输出结果。如果想保存结果该怎么办呢？</p>
<p>要完成这个任务其实不需要任何额外的代码，Scrapy 提供的 Feed Exports 可以轻松将抓取结果输出。例如，我们想将上面的结果保存成 JSON 文件，可以执行如下命令：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure>

<p>命令运行后，项目内多了一个 quotes.json 文件，文件包含了刚才抓取的所有内容，内容是 JSON 格式。</p>
<p>另外我们还可以每一个 Item 输出一行 JSON，输出后缀为 jl，为 jsonline 的缩写，命令如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.jl</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.jsonlines</span></span><br></pre></td></tr></table></figure>

<p>输出格式还支持很多种，例如 csv、xml、pickle、marshal 等，还支持 ftp、s3 等远程输出，另外还可以通过自定义 ItemExporter 来实现其他的输出。</p>
<p>例如，下面命令对应的输出分别为 csv、xml、pickle、marshal 格式以及 ftp 远程输出：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.csv</span></span><br><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.xml</span></span><br><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.pickle</span></span><br><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.marshal</span></span><br><span class="line">scrapy crawl <span class="attribute">quotes</span> -o ftp://user:pass@ftp.example.com/path/to/quotes.csv</span><br></pre></td></tr></table></figure>

<p>其中，ftp 输出需要正确配置用户名、密码、地址、输出路径，否则会报错。</p>
<p>通过 Scrapy 提供的 Feed Exports，我们可以轻松地输出抓取结果到文件。对于一些小型项目来说，这应该足够了。不过如果想要更复杂的输出，如输出到数据库等，我们可以使用 Item Pileline 来完成。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式爬虫解析与实践</title>
    <url>/2020/10/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="分布式爬虫解析与实践"><a href="#分布式爬虫解析与实践" class="headerlink" title="分布式爬虫解析与实践"></a>分布式爬虫解析与实践</h2><p>lsof -ni | grep LISTEN</p>
]]></content>
  </entry>
  <entry>
    <title>字节跳动2020-ByteCamp暑期夏令营研发组习题</title>
    <url>/2020/08/01/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82020%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要是记录字节2020夏令营的笔试习题，解答部分待日后不断完善。<br>选择题部分记录不是很完全，剩下没有被收录的大都偏容易。</p>
<a id="more"></a>
<h2 id="单项选择题"><a href="#单项选择题" class="headerlink" title="单项选择题"></a>单项选择题</h2><ol>
<li>箱子里有20个红球，18个白球，逐一随机抽取球，问整个过程中箱外白球至少有一次和箱外红球相等的概率。</li>
<li>求f(x)=x-sinx的零点个数</li>
</ol>
<h2 id="多项选择题"><a href="#多项选择题" class="headerlink" title="多项选择题"></a>多项选择题</h2><ol>
<li>假设在单核无超线程CPU场景下执行如下代码「x=x+1,y=y+x」，有三个线程分别执行这段代码，在所有线程开始前，假设有2个变量x,y，x和y都被初始化为1，x和y值会且只会被这三个线程修改，线程随时会被抢占，设该代码均为原子的，则可能得到的结果？</li>
</ol>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ol>
<li>有一台机器，可批量输入单词，会返回其翻译值，但是不知道对应关系，现有1000个单词，问最少需要（）次才可以确定它们的翻译。</li>
<li>幼儿园阿姨买了很多糖果，让6位小朋友早上自己分糖果，第一个先分成相等6堆，结果发现多出来1颗，于是他吃了一颗然后拿走一堆，剩下五堆；第二个小朋友把五堆合在一起，又分了6堆，结果发现又多了一个，于是他也吃了一颗拿走一堆，剩下的亦如此。问阿姨至少买了多少颗糖。</li>
</ol>
<h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><ol>
<li><p><strong>题目描述：</strong></p>
<p>小包有一个纪念日，他特别喜欢这个日子，于是把它以”DD-MM-YYYY” (如:31-01-2020，代表2020年1月31日) 的格式记录了下来。但小包不想被别人知道这个日子，于是他将这个日子与很多别的日子写在一起，且该日子的出现次数最多。<br>小包不小心忘记了纪念日到底是哪天，所以小包现在需要从之前的记录中找到这个纪念日。</p>
<p><strong>输入描述：</strong></p>
<p>一行一个字符串，其中只包含数字和字符”-“，字符串长度不超过10^5。<br>2001 &lt;= YYYY &lt;= 2020<br>01&lt;=MM&lt;=12<br>DD满足每个月份的日期数，需要考虑闰年的2月<br>MM和DD不够两位数时会填充前导0，如2020年1月1日会写成01-01-2020而不是1-1-2020。<br>输入保证一定存在一个符合要求的合法的日期，且保证一定存在一个日期出现次数严格大于别的日期出现次数。</p>
<p><strong>输出描述：</strong></p>
<p>纪念日日期，以DD- MM-YYYY”的格式。</p>
<p><strong>示例1:</strong></p>
<p>输入：20-12-2030-12-2020</p>
<p>输出：30-12-2020</p>
<p>说明：符合条件的日期只有30-12-2020这一个。注意数据中的20-12-2030年份超出了2001 &lt;= YYYY &lt;= 2020范围，因此不计算在内。</p>
</li>
<li><p><strong>题目描述：</strong></p>
<p>字节跳动有很多个机房，每个机房可能会有很多个网段(如 10.1.2.0/24)，网段之间会有包含关系，当出现包含关系时，以小的网段为准。如机房1对应网段10.1.0.0/16，机房2对应网段10.1.2.0/24，那么现在有一个IP 10.1.2.3，其应当归属于机房2。</p>
<p>公司内我们经常会遇到一个场景:要查询一个IP所在的机房。请你写一个程序，根据输入的网段信息和所需查询的IP给出所在的机房。为了简化问题，在这里我们认为所有IP都是可分配的，即不考虑网段地址和广播地址，将这两种地址也认为是可分配地址。</p>
<p><strong>输入描述：</strong></p>
<p>第一行包含两个整数n和m。随后n行，每行有两部分组成，第一部分是机房编号，第二部分是网段信息，格式如下:<br>idc net<br>随后m行，每行是一个IP，表示需要查询的IP。<br>保证所有的网段以及IP都为IPV4格式，不存在IPV6 的输入数据。<br>要注意，输入可能存在一个大网段被多个小网段切分完毕的情况。</p>
<p>数据范围:<br>对于30%的数据:1&lt;=n&lt;=10、1&lt;=m&lt;=100;<br>对于60%的数据，1&lt;=n&lt;=1000、1&lt;=m&lt;=5000;<br>对于100%的数据，1&lt;=n&lt;=5000、1&lt;=m&lt;=50000。</p>
<p><strong>输出描述：</strong></p>
<p>输出一共有m行，每行为一个整数，代表第Mi行IP对应的机房编号。<br>如果所输入的IP没有找到对应的网段信息，就输出-1。</p>
<p><strong>示例1:</strong></p>
<p> 输入：</p>
   <figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>	<span class="number">4</span>   </span><br><span class="line"><span class="symbol">1 </span><span class="number">10.1.2.0</span>/<span class="number">24</span>  </span><br><span class="line"><span class="symbol">2 </span><span class="number">10.1.0.0</span>/<span class="number">16</span>   </span><br><span class="line"><span class="symbol">1 </span><span class="number">10.1.5.0</span>/<span class="number">24</span>   </span><br><span class="line"><span class="symbol">2 </span><span class="number">10.1.2.128</span>/<span class="number">125</span>  </span><br><span class="line"><span class="number">10.1.2.3</span> </span><br><span class="line"><span class="number">10.1.2.129</span></span><br><span class="line"><span class="number">10.3.2.1</span></span><br><span class="line"><span class="number">10.1.5.2</span></span><br></pre></td></tr></table></figure>

<p>  输出：</p>
   <figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>题目描述：</strong></p>
<p>两姐妹小蔓和小玉玩抽牌游戏:一共n张牌，两人轮流抽排，先手者的第一次抽可以抽任意张但不可抽完，以后每次抽都只能抽取不超过上一次抽牌数的两倍(不可不抽)。谁先抽完牌谁赢(没得抽的算输)。由姐姐小蔓先抽。假设该游戏会进行t轮，每轮重新给出新的n。请问先手的姐姐小蔓一共能赢其中的多少轮呢?(注:两姐妹冰雪聪明，都会做出对自己最优的策略)</p>
<p><strong>输入描述：</strong></p>
<p>第一行，一个数字t<br>接下来t行，每行一个数字，n</p>
<p><strong>输出描述：</strong></p>
<p>一个数字x，代表姐姐小蔓赢得轮数</p>
<p><strong>示例1:</strong></p>
<p>输入：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">​<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>输出：1</p>
<p>说明： </p>
<p>2&lt;=n&lt;=1e9</p>
<p>30%的数据(1&lt;=t&lt;=10^3)</p>
<p>60%的数据(1&lt;=t&lt;=10^5)</p>
<p>100%的数据(1&lt;=t&lt;=10^6)</p>
</li>
<li><p><strong>题目描述：</strong></p>
<p>我们在使用Tensorflow等编写神经网络时，为了使代码逻辑清晰，可能会造成运行时的低效。小熊写出了如下的计算式:</p>
<blockquote>
<p>(p0-(p1 /(p0 + (p3-p4))))+ (p2*(p1 /(p0 + (p3- p4))</p>
</blockquote>
<p>在Tensorflow中可以表示为如下图一，其中p1/ (p0 + (p3 - p4))计算了两次。还好Tensorlfow提供的XL A(Accelerated Linear Algebra)对此进行了优化，只需计算一次，计算流程被优化为如下图二形式。</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a3Nlw9.png" alt="a3Nlw9.png"></p>
<p>小熊露出了满意的笑容的同时，开始思考这个过程是怎么完成的。他已经把这个问题简化，他使用前缀表示法来表示这些计算式，并限定操作符于{+,-, *,/}，操作数为单个小写字母。可描述如下:</p>
<blockquote>
<p>E in{a, b,…Z}<br>f in{t,-,*k,/}<br>F= f(E, E)<br>F= f(E, F)</p>
</blockquote>
<p>令上述表达式中p0=a, p1=b, p2=c, p3=d, p4=e，前缀表示法可表示为:</p>
<blockquote>
<p>+(-(a,/(b,+(a,-(d,e)))),*(c,/(b,+(a,-(d,e)))))</p>
</blockquote>
<p>他希望能将这个表达式的计算节点优化到最少，能不能帮他写个程序来完成这个任务?<br>对于每个表达式，将其计算节点优化到最少。并将优化的子表达式以一个数字表示，这个数字指向等于此子表达式的根节点的序号。节点的序号从1开始，按前序遍历分配，如果是重复节点则不分配编号。如”a+a”可转换为前缀表达式”+(a,a)”，第二个”a”发现第一个”a”作为节点(编号2)已经出现过，因此可优化为”+(a,2)”，2表示指向编号为2的节点。</p>
<p>而在”+(-(a,/(b,+(a,-(d,e)))),(c,/(b,+(a,-(d,e)))))”中，”a”和”/(b,+(a,-(d,e)))”都是重复的， 其中a第一次出现的节点编号为3,”/(b,+(a,-(d,e)))”第一 次出现的根节点”/“编号为4，因此可以优化为”+(-(a,/(b,+(3,-(d,f)))),*(c,4))”。</p>
<p><strong>输入描述：</strong></p>
<p>第一行包含一个数字c，表示将要处理的表达式行数，不超过200行。接下来的c行每行包含一个表达式，表达式的形式由上述给出(已转换为前缀形式，无空格，有括号)。最多包含10000个节点。</p>
<p><strong>输出描述：</strong></p>
<p>对于每个表达式，输出按说明中优化后的表达式。</p>
<p><strong>示例1:</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/01/a3N1oR.png" alt="a3N1oR.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>面向求职汇总</category>
      </categories>
      <tags>
        <tag>笔试习题</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习笔记整理</title>
    <url>/2020/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文主要是总结操作系统的一些知识点，方便日后查阅。</p>
<a id="more"></a>

<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p>总线</p>
<h2 id="第一章：操作系统引论"><a href="#第一章：操作系统引论" class="headerlink" title="第一章：操作系统引论"></a>第一章：操作系统引论</h2><h3 id="1-1-操作系统的发展与分类"><a href="#1-1-操作系统的发展与分类" class="headerlink" title="1.1 操作系统的发展与分类"></a>1.1 操作系统的发展与分类</h3><h4 id="1-1-1-手工操作阶段"><a href="#1-1-1-手工操作阶段" class="headerlink" title="1.1.1 手工操作阶段"></a>1.1.1 手工操作阶段</h4><h4 id="1-1-2-批处理操作系统"><a href="#1-1-2-批处理操作系统" class="headerlink" title="1.1.2 批处理操作系统"></a>1.1.2 批处理操作系统</h4><p>设置完成作业（作业=程序+数据+作业说明书）自动转换工作的程序</p>
<ul>
<li><p>单道批处理系统</p>
<p>用户作业——&gt;系统管理员—==脱机输入==—&gt;磁盘（通过监督程序）</p>
<p>特点：单道性，顺序性，自动性</p>
<p>问题：</p>
<ul>
<li>CPU和I/O设备串行工作</li>
</ul>
</li>
<li><p>多道批处理系统</p>
<p>内存中同时驻留多个独立程序，共享资源穿插进行</p>
<p>特点：多道性，无序性，调度性；宏观并行、微观串行</p>
<p>优点：提高CPU利用率（CPU切换频率低）；提高内存和I/O设备利用率；增加系统吞吐量</p>
<p>缺点：</p>
<ul>
<li>平均周转时间长（周转时间：从作业装入系统开始，到运行完成并退出系统为止）</li>
<li>无交互能力</li>
</ul>
</li>
</ul>
<h4 id="1-1-3-分时操作系统"><a href="#1-1-3-分时操作系统" class="headerlink" title="1.1.3 分时操作系统"></a>1.1.3 分时操作系统</h4><p>时间片：每个终端用户的作业能连续使用CPU的最长时间</p>
<p>关键问题：人机交互</p>
<p>特点：==多路性==，独立性，及时性，交互性</p>
<h4 id="1-1-4-实时操作系统"><a href="#1-1-4-实时操作系统" class="headerlink" title="1.1.4 实时操作系统"></a>1.1.4 实时操作系统</h4><p>关键词：截止时间</p>
<ul>
<li><p>开始截止时间</p>
<p>必须在某个时间点开始，否则任务无法按时完成，即任务开始时间不得晚于开始截止时间。</p>
</li>
<li><p>完成截止时间</p>
<p>必须在某个时间点完成，否则任务无法按时结束，即任务结束时间不得晚于完成截止时间。</p>
</li>
</ul>
<p>与分时系统的比较：</p>
<ul>
<li>设计目的不同</li>
<li>特点：及时性，交互性，可靠性</li>
</ul>
<h3 id="1-2-操作系统的特征和功能"><a href="#1-2-操作系统的特征和功能" class="headerlink" title="1.2 操作系统的特征和功能"></a>1.2 操作系统的特征和功能</h3><h4 id="1-2-1-操作系统的特征"><a href="#1-2-1-操作系统的特征" class="headerlink" title="1.2.1 操作系统的特征"></a>1.2.1 操作系统的特征</h4><ol>
<li><p><strong>并发</strong></p>
<p>定义：两个或多个事件在同一时间间隔内同时发生。</p>
<p><strong>并行与并发的区别：</strong></p>
<p>–并行性：两个或多个事件在同一时刻同时发生。</p>
<p>–并发性：宏观上在同一时间段内同时运行，微观上交替执行。并发特征是OS最重要的特征。</p>
<p><strong>注：并发是宏观上同时发生，微观上串行；并行指的是微观上同时发生。</strong></p>
</li>
<li><p><strong>共享</strong></p>
<p>定义：指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li><p>互斥共享方式：</p>
<p>在一段时间内只允许一个进程访问资源</p>
<p>临界资源（独占资源）：在一段时间内只允许一个进程访问的资源</p>
</li>
<li><p>同时访问方式：</p>
<p>宏观上在一段时间内允许多个进程“同时”访问某些资源</p>
<p>微观上“轮流”（交替访问）</p>
<p>处理机、内存、磁盘、可重入代码</p>
</li>
</ul>
</li>
<li><p><strong>虚拟</strong></p>
<p>定义：是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gizpz7zsf6j31cg0ig1kx.jpg" alt=""></p>
</li>
<li><p><strong>异步（不确定性）</strong></p>
<p>进程是以人们不可预知的速度向前推进的。</p>
<p>导致的原因：竞争资源。</p>
</li>
</ol>
<h4 id="1-2-2-操作系统的功能"><a href="#1-2-2-操作系统的功能" class="headerlink" title="1.2.2 操作系统的功能"></a>1.2.2 操作系统的功能</h4><ol>
<li>处理机管理</li>
<li>存储器管理</li>
<li>设备管理</li>
<li>文件管理</li>
<li>提供用户接口</li>
</ol>
<h3 id="1-3-操作系统的用户接口"><a href="#1-3-操作系统的用户接口" class="headerlink" title="1.3 操作系统的用户接口"></a>1.3 操作系统的用户接口</h3><h4 id="1-3-1-命令接口（CLI）"><a href="#1-3-1-命令接口（CLI）" class="headerlink" title="1.3.1 命令接口（CLI）"></a>1.3.1 命令接口（CLI）</h4><p>在终端中使用，完成系统管理任务，例如linux中的bash、sh</p>
<h4 id="1-3-2-程序接口（API）"><a href="#1-3-2-程序接口（API）" class="headerlink" title="1.3.2 程序接口（API）"></a>1.3.2 程序接口（API）</h4><p>程序接口是应用程序以函数调用的方式来使用系统服务的接口，在Unix/Linux系统中也称为系统调用（system call）。</p>
<p>==系统调用：==</p>
<p>系统功能调用是用户在程序一级请求操作系统服务的一种手段，它是带有一定功能号的“访管指令”。其功能是由操作系统中的程序完成的，即由软件方法实现的。</p>
<p>==系统调用与库函数的区别：==</p>
<p>(1)库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分</p>
<p>(2)库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间，库函数开销较小，系统调用开销较大</p>
<p>(3)库函数是有缓冲的，系统调用是无缓冲的</p>
<p>(4)系统调用依赖于平台，库函数并不依赖</p>
<h4 id="1-3-3-图形接口（GUI）"><a href="#1-3-3-图形接口（GUI）" class="headerlink" title="1.3.3 图形接口（GUI）"></a>1.3.3 图形接口（GUI）</h4><h3 id="1-4-操作系统的内核结构"><a href="#1-4-操作系统的内核结构" class="headerlink" title="1.4 操作系统的内核结构"></a>1.4 操作系统的内核结构</h3><h4 id="1-4-1-整体结构"><a href="#1-4-1-整体结构" class="headerlink" title="1.4.1 整体结构"></a>1.4.1 整体结构</h4><p>整体结构模型又称为单体结构模型或者无结构模型，特点是<strong>无明确定义和划分操作系统的结构，函数之间可以任意相互调用。</strong></p>
<p>例如MS-DOS、Linux系统以及早期的Unix系统。</p>
<p>优点：接口关系简单直接，系统效率较高</p>
<p>缺点：模块独立性差，调用关系复杂</p>
<h4 id="1-4-2-层次结构"><a href="#1-4-2-层次结构" class="headerlink" title="1.4.2 层次结构"></a>1.4.2 层次结构</h4><p>层次结构模型的特点是各层模块只能单向依赖或单向调用，最底层（第0层）与低层硬件交互，最高层给应用程序和用户提供接口，且只有相邻层才可以进行通信，即上层模块可以调用下层模块的功能，反之不行。例如VAX和Unix系统。</p>
<p>优点：结构清晰，整体问题局部化，简化系统设计与实现，易于维护修改和扩充</p>
<p>缺点：系统开销增加效率降低，各层次包含的内容难于确定</p>
<h4 id="1-4-3-微内核结构"><a href="#1-4-3-微内核结构" class="headerlink" title="1.4.3 微内核结构"></a>1.4.3 微内核结构</h4><p>微内核结构由<strong>非常简单的硬件抽象层和关键的原语或系统调用</strong>组成，仅仅包括了最基本的操作系统功能。例如Windows和macOS。</p>
<p>优点：具有良好的扩充性，可靠性</p>
<p>缺点：效率低</p>
<h3 id="第一章练习题"><a href="#第一章练习题" class="headerlink" title="第一章练习题"></a>第一章练习题</h3><ol>
<li>操作系统有多种类型，允许多个用户以交互的方式使用计算机的操作系统，称为(分时操作系统)；允许多个用户将若干个作业提交给计算机系统集中处理的操作系统，称为(多道批处理系统)；在(实时操作系统 )的控制下，计算机系统能及时处理由过程控制反馈的数据，并及时作出响应。</li>
<li>实时系统对可靠性和安全性要求极高，它（不强求系统资源利用率）。</li>
<li>批处理系统中，作业成批存入（外存），等待作业调度。</li>
<li>在多道程序设计技术的计算机系统中，CPU（可以被多个进程交替占用）。</li>
<li>中断向量是指（中断处理程序的入口地址），由处理机自动寻址。中断向量地址实质就是中断处理程序的入口地址的地址，也就是中断服务例行程序入口地址的地址。</li>
<li>当计算机区分了核心态和用户态指令之后，从核心态到用户态的转换是由操作系统程序执行后完成的，而用户态到核心态的转换则是由(硬件)完成的。</li>
<li>从用户的观点看，操作系统是（使用计算机硬件系统的接口）。</li>
<li>操作系统最主要的设计目标是（方便性和有效性）。</li>
<li>多道批处理系统的硬件支持来自20世纪60年代初发展起来的（中断与通道技术）。</li>
<li>在单处理器系统中实现并发技术后(各进程在一个时间段内并行运行，CPU与外设间并行工作 )。</li>
<li>用户程序在用户态下使用系统调用引起的中断属于（访管中断）。</li>
<li>时钟中断事件属于（外部中断时间）。</li>
<li>计算机系统中判断是否有外部中断事件发生应该在（执行完一条指令之后）。</li>
<li>外部中断是由与现行指令无关的中断信号触发的，因此外部中断的发生与CPU处在用户态或内核态无关。（✅）</li>
<li>在操作系统的层次结构中，（处理器管理）是操作系统的核心，它位于最内层。</li>
<li>中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调用不需要保存其内容的是（程序状态字）。</li>
</ol>
<h2 id="第二章：操作系统硬件基础"><a href="#第二章：操作系统硬件基础" class="headerlink" title="第二章：操作系统硬件基础"></a>第二章：操作系统硬件基础</h2><h3 id="2-1-处理器特权级"><a href="#2-1-处理器特权级" class="headerlink" title="2.1 处理器特权级"></a>2.1 处理器特权级</h3><p><strong>处理机的状态分类：</strong></p>
<ul>
<li><p>管态 (Supervisor mode)：系统态<br>操作系统执行时机器所处的状态，又称处理机的特权级。在此状态下处理机可使用全部指令(包括一组特权指令)；使用全部系统资源(包括整个存储区域)。</p>
</li>
<li><p>目态(User mode)：用户态</p>
<p>用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域。</p>
<table>
<thead>
<tr>
<th>管态（系统态）</th>
<th>目态（用户态）</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统的程序执行</td>
<td>用户程序执行</td>
</tr>
<tr>
<td>使用全部指令</td>
<td>禁止使用特权指令</td>
</tr>
<tr>
<td>使用全部系统资源(包括整个存储区域)</td>
<td>只允许用户程序访问自己的存储区域</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>特权指令：</strong></p>
<p>① 涉及外部设备的输入/输出指令<br>② 修改特殊寄存器的指令：CPU状态寄存器PS、段地址寄存器、时钟寄存器、I/O设备控制寄存器等<br>③ 改变机器状态的指令：停机指令、中断返回指令、禁止中断指令等</p>
<h3 id="2-2-中断和时钟"><a href="#2-2-中断和时钟" class="headerlink" title="2.2 中断和时钟"></a>2.2 中断和时钟</h3><p><strong>中断的概念：</strong></p>
<p>是指CPU暂停执行当前的指令流程，去处理外部设备或硬件的中断信号的过程 。</p>
<p><strong>中断类型：</strong></p>
<ul>
<li><p>按中断功能分：</p>
<p>① 输入输出中断：I/O传输结束或出错中断<br>② 外中断：==时钟中断==、操作员控制台中断、通信中断等<br>③ 机器故障中断：电源故障、主存取指令错等<br>④ 程序性中断：定点溢出、用户态下用核态指令、非法操作<br>⑤ ==访管中断==：对操作系统提出某种需求时所发出的中断</p>
</li>
<li><p>按中断来源分：</p>
<p>① 中断（外中断）：处理机外部事件引起<br>② 俘获（内中断）：处理机内部事件引起，x86中称异常</p>
<blockquote>
<p>同时异常也分为两类：分别是<strong>处理器探测异常</strong>和<strong>编程异常</strong>，前者指处理器执行指令时探测到的反常条件所产生的异常；后者则是由编程者发出请求产生的异常，通常也叫做软中断，也通常被当作陷阱。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gizpz7qjojj31360gwtaf.jpg" alt=""></p>
</li>
</ul>
<p><strong>系统调用顺序：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gizpxvh6qej30z40o2tgv.jpg" alt="image-20200922204154797"></p>
<h3 id="第二章练习题"><a href="#第二章练习题" class="headerlink" title="第二章练习题"></a>第二章练习题</h3><ol>
<li>操作系统提供了多种界面供用户使用，其中（系统调用）是专门供应用程序使用的一种界面。</li>
<li>当操作系统完成用户请求的“系统调用”功能后，应使CPU（从内核态转至用户态）工作。</li>
<li>访管指令为非特权指令，在<strong>用户态下执行时</strong>会将CPU转换为内核态。（✅）</li>
<li>设计用户程序时，使用系统调用命令，该命令经过编译后，形成若干参数和陷入指令。（✅）</li>
<li>从应用程序的使用角度看，库函数与系统调用没有差别；但从实现的角度看，两种有重大差别。（✅）</li>
<li>用户及其应用程序和应用系统是通过系统调用提供的支持和服务来使用系统资源完成其操作的。（✅）</li>
</ol>
<h2 id="第三章：进程管理"><a href="#第三章：进程管理" class="headerlink" title="第三章：进程管理"></a>第三章：进程管理</h2><h3 id="3-1-进程的引入"><a href="#3-1-进程的引入" class="headerlink" title="3.1 进程的引入"></a>3.1 进程的引入</h3><h4 id="3-1-1-程序执行模式"><a href="#3-1-1-程序执行模式" class="headerlink" title="3.1.1 程序执行模式"></a>3.1.1 程序执行模式</h4><ul>
<li><p>程序的顺序执行</p>
<p>顺序性、封闭性、可再现性（程序的运行结果与其推进速度无关）</p>
</li>
<li><p>程序的并发执行</p>
<p>间断性（运行-暂停-运行）、失去封闭性导致程序结果出现不可再现性，即<strong>与时间有关的错误</strong></p>
</li>
<li><p>静态程序结构不能支持并发运行实现</p>
</li>
</ul>
<h4 id="3-1-2-进程管理功能"><a href="#3-1-2-进程管理功能" class="headerlink" title="3.1.2 进程管理功能"></a>3.1.2 进程管理功能</h4><ol>
<li><p><strong>进程控制：</strong> 控制进程状态转换</p>
</li>
<li><p><strong>进程互斥与同步：</strong>协调进程间的运行顺序</p>
<p>互斥方式：进程间竞争临界资源</p>
<p>同步方式：进程间相互合作</p>
</li>
<li><p><strong>进程通信：</strong>进程间的信息交换</p>
</li>
<li><p><strong>调度：</strong> 作业调度，进程调度</p>
</li>
</ol>
<h3 id="3-2-进程概念"><a href="#3-2-进程概念" class="headerlink" title="3.2 进程概念"></a>3.2 进程概念</h3><h4 id="3-2-1-进程的定义及特征"><a href="#3-2-1-进程的定义及特征" class="headerlink" title="3.2.1 进程的定义及特征"></a>3.2.1 进程的定义及特征</h4><p><strong>定义：</strong></p>
<p>可并发执行的程序在一个数据集合上的一次运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<p><strong>特征：</strong></p>
<p>动态性：进程最基本的特征</p>
<p>并发性：程序在建立进程后并发运行</p>
<p>独立性：是系统进行资源分配和调度的独立单位  </p>
<p>异步性：进程以不可预知的速度向前推进 </p>
<ul>
<li><p><strong>进程映像（进程实体的组成，也是进程的结构特征）</strong></p>
<ol>
<li><p>可执行的程序段</p>
</li>
<li><p>相关数据集(变量、工作空间，缓冲区等) </p>
<p>程序和数据负责描述进程本身所应完成的功能</p>
</li>
<li><p>栈(内核栈/用户栈)：过程调用相关信息(返址、参数传递、局部变量等)</p>
</li>
<li><p>PCB：记录进程的动态特征，该进程与其他进程和系统资源的关系。（PCB是进程存在的唯一标识）</p>
</li>
</ol>
</li>
<li><p><strong>进程与程序的区别</strong></p>
<p>从定义上看，进程是程序处理数据的过程，而程序是一组指令的有序集合；</p>
<p>进程具有动态性、并发性、独立性和异步性等，而程序不具有这些特性；</p>
<p>从进程结构特性上看，它包含程序、数据（栈）和PCB；</p>
<p>进程和程序并非一一对应：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可执行多个程序。</p>
</li>
</ul>
<h4 id="3-2-2-进程状态及转换"><a href="#3-2-2-进程状态及转换" class="headerlink" title="3.2.2 进程状态及转换"></a>3.2.2 进程状态及转换</h4><ol>
<li><p><strong>三种基本的状态及其状态转换</strong></p>
<p>就绪状态：进程分配到必要的资源，等待获得CPU执行的状态。 组织成一个或多个就绪队列。</p>
<p>运行状态：进程已经分配到CPU，正在CPU上执行时的状态。</p>
<p>阻塞状态（等待状态、睡眠状态）：正在执行的进程由于等待某事件的发生而暂时无法继续执行时，便放弃处理机而处于暂停状</p>
<p>态。组织成一个或多个阻塞队列。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1zbz7xsbj30xq0i6dje.jpg" alt=""></p>
</li>
<li><p><strong>创建状态和终止状态</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1ze6suz8j311a0hiwie.jpg" alt=""></p>
</li>
</ol>
<h4 id="3-2-3-进程控制块PCB-process-control-block"><a href="#3-2-3-进程控制块PCB-process-control-block" class="headerlink" title="3.2.3 进程控制块PCB(process control block)"></a>3.2.3 进程控制块PCB(process control block)</h4><ol>
<li><p><strong>进程标识信息</strong></p>
<ul>
<li>进程标识符</li>
<li>用户标识符</li>
<li>家族关系</li>
</ul>
</li>
<li><p><strong>进程调度信息</strong></p>
<ul>
<li>进程状态；</li>
<li>进程优先级；</li>
<li>进程的时间片；</li>
<li>等待事件；</li>
<li>其他调度相关信息</li>
</ul>
</li>
<li><p><strong>进程现场信息</strong></p>
<ul>
<li>通用寄存器</li>
<li>段寄存器</li>
<li>指令计数器的值</li>
<li>程序状态字（PSW）</li>
<li>栈指针</li>
</ul>
</li>
<li><p><strong>进程控制信息</strong></p>
<ul>
<li><p>程序和数据地址</p>
</li>
<li><p>进程同步信息</p>
</li>
<li><p>进程通信信息</p>
</li>
<li><p>资源管理信息</p>
</li>
<li><p>链接指针</p>
<p><strong>链接方式：</strong></p>
<p>就绪队列、执行进程、阻塞队列、空白PCB队列（加快创建进程速度）</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-3-进程控制"><a href="#3-3-进程控制" class="headerlink" title="3.3 进程控制"></a>3.3 进程控制</h3><h4 id="3-3-1-进程原语（primitive）"><a href="#3-3-1-进程原语（primitive）" class="headerlink" title="3.3.1 进程原语（primitive）"></a>3.3.1 进程原语（primitive）</h4><p>由若干条指令构成的“原子操作(atomic operation)”过程，完成某种特定的功能，作为一个整体而不可分割－－要么全都完成，要么全都不做。</p>
<p><strong>进程控制原语：</strong></p>
<ol>
<li>创建进程原语</li>
<li>撤销进程原语</li>
<li>阻塞进程原语</li>
<li>唤醒进程原语</li>
</ol>
<h4 id="3-3-2-进程创建"><a href="#3-3-2-进程创建" class="headerlink" title="3.3.2 进程创建"></a>3.3.2 进程创建</h4><ol>
<li><p><strong>进程图：</strong> 描述进程家族关系的有向树</p>
<p><strong>引起进程创建的典型事件：</strong>作业调度、用户登录、提供特定服务、应用请求</p>
</li>
<li><p><strong>进程创建原语：</strong></p>
<p>创建一个新进程，建立进程的PCB结构并为其分配资源。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj62k6xqboj30zc0lyk0o.jpg" alt=""></p>
</li>
</ol>
<h4 id="3-3-3-进程撤销"><a href="#3-3-3-进程撤销" class="headerlink" title="3.3.3 进程撤销"></a>3.3.3 进程撤销</h4><ol>
<li><p><strong>引起进程撤销的典型事件：</strong></p>
<ul>
<li>进程正常运行结束而撤销</li>
<li>进程异常终止而撤销</li>
<li>进程应外界干预而终止：<ul>
<li>操作员或操作系统干预</li>
<li>父进程</li>
<li>父进程被撤销</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程撤销过程（kill(Pid)函数）：</strong>回收进程资源</p>
<p>正在执行的进程，当发现下述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block把自己阻塞。可见，<strong>进程的阻塞是进程自身的一种主动行为。</strong>进入block过程后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。 最后，转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态(在PCB中)，再按新进程的PCB中的处理机状态设置CPU的环境。 </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj63ne6crtj30m20m0afv.jpg" alt=""></p>
</li>
</ol>
<h4 id="3-3-4-进程阻塞与唤醒"><a href="#3-3-4-进程阻塞与唤醒" class="headerlink" title="3.3.4 进程阻塞与唤醒"></a>3.3.4 进程阻塞与唤醒</h4><ol>
<li><p><strong>引起进程阻塞与唤醒的典型事件</strong>：</p>
<ul>
<li>当前进程请求资源失败</li>
<li>当前进程需要等待某种操作的完成</li>
<li>当前进程的前驱进程尚未完成</li>
<li>当前进程无新工作可做</li>
</ul>
</li>
<li><p><strong>进程阻塞过程（sleep()函数）</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj641vwrwnj30r80legri.jpg" alt="image-20200928093228955"></p>
</li>
<li><p><strong>进程唤醒过程（wakeup()函数）</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj644f3v20j30xc0hedly.jpg" alt="image-20200928093436006"></p>
</li>
</ol>
<h4 id="3-3-5-Linux进程管理"><a href="#3-3-5-Linux进程管理" class="headerlink" title="3.3.5 Linux进程管理"></a>3.3.5 Linux进程管理</h4><ol>
<li><p><strong>Linux进程实体组成</strong></p>
<ul>
<li><p>进程控制块（task_struct）</p>
</li>
<li><p>正文段：进程要运行的程序代码</p>
</li>
<li><p>数据段：又分为用户数据段和系统数据段</p>
<ul>
<li><strong>用户数据段：</strong>进程在用户态下执行时直接操作的所有数据，包括全部变量及用户栈。</li>
<li><strong>系统数据段：</strong>主要是内核栈。保存中断现场信息和进程在内核态下执行函数嵌套调用的返回现场信息。</li>
<li><strong>内核栈的大小是静态确定的，而用户栈可以在进程运行时动态扩展</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Linux进程创建</strong></p>
<ul>
<li><p>系统提供fork()、vfork()和clone()系统调用</p>
<ul>
<li><p>fork()： </p>
<p>fork 创造的子进程以copy_on_write技术<strong>复制</strong>父亲进程的所有资源，父子进程使用同一代码段, 数据段和堆栈段，task_struct内容也基本相同 。</p>
</li>
<li><p>vfork()：</p>
<p>vfork()创建的子进程<strong>完全运行在父进程的地址空间上</strong>，子进程对虚拟地址空间任何数据的修改都为父进程所见。</p>
<p>vfork()创建子进程后，父进程会被阻塞，直到子进程执行exit()。</p>
</li>
<li><p>clone()：</p>
<p>功能强大，可以有选择性的继承父进程的资源，用来创建轻量级进程 (线程)</p>
</li>
<li><p><strong>返回值：</strong></p>
<p>＜0：  出错，创建失败</p>
<p> =0：从子进程返回，即现在正执行新创建的子进程</p>
<p>＞0：从父进程返回，即现在正执行父进程，返回值为新创建的子进程的PID</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>进程创建例题：</p>
<p>1.在Linux系统中运行如下程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">   <span class="keyword">int</span> num=<span class="number">0</span>；</span><br><span class="line">   fork();</span><br><span class="line">   <span class="built_in">printf</span>(“hello1\n”)：</span><br><span class="line">   fork()；</span><br><span class="line">   <span class="built_in">printf</span>(“hello2\n”);</span><br><span class="line">   fork();</span><br><span class="line">   num++；</span><br><span class="line">   <span class="built_in">printf</span>(“hello3\n”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）最多可产生多少个进程？画出进程家族树。（包含main进程在内）</p>
<p>（2）其中hello1、hello2、hello3各被输出多少次？</p>
<p>（3） num最后的计算结果的最大值是多少？如果将程序中的fork()换成vfork()，则num最后的计算结果的最大值又是多少？</p>
<p>解：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7d5th4qxj32h30u0n2k.jpg" alt=""></p>
<blockquote>
<p>Hello1 Hello2 Hello3各被输出 2 4 8次</p>
<p>fork下：num计算结果最大值为1</p>
<p>vfork下：num计算结果最大值为8</p>
</blockquote>
<p>这类题的整体思路就是“复制粘贴”。只要看到fork就把这一个fork下面的所有内容“复制粘贴”成为另外一个独立的代码段运行就好；vfork不会“复制粘贴”，只会分出去运行。</p>
<p>2.题目如下所示，分析可能输出的结果。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj7df2nnpnj31040kse0e.jpg" alt="image-20200929114206286"></p>
<p>简单来讲就是fork（）使用的时候父子进程各走各的，各自都有缓存区（子进程的是复制父进程的）；vfork（）使用时子进程先运行，子进程退出后在运行父进程，缓存区父子共用，也就是说子进程将缓存区的内容输出后父进程就没有需要输出的内容了。</p>
</li>
</ul>
<h3 id="3-4-进程同步"><a href="#3-4-进程同步" class="headerlink" title="3.4 进程同步"></a>3.4 进程同步</h3><h4 id="3-4-1-进程同步的基本概念"><a href="#3-4-1-进程同步的基本概念" class="headerlink" title="3.4.1 进程同步的基本概念"></a>3.4.1 进程同步的基本概念</h4><ol>
<li><p><strong>并发进程间的间接制约关系与进程互斥</strong></p>
<ul>
<li><p><strong>临界资源：</strong>（互斥共享避免与时间有关的错误）</p>
<p>一次仅允许一个进程使用的资源，如打印机、公用变量、数据等。</p>
</li>
<li><p><strong>临界区：</strong></p>
<p>每个进程中访问临界资源的那段代码称为临界区，通常临界区前后会有<strong>进入区</strong>和<strong>退出区</strong>。</p>
<ul>
<li><p><strong>进入区：</strong></p>
<p>在进入临界区之前需要对欲访问的临界资源进行检查，看是否被其他进程正在访问，如果未被其他进程正在访问，则将该进程送入临界区并将临界资源状态设置为“忙”。</p>
</li>
<li><p><strong>退出区：</strong></p>
<p>进程访问完临界资源退出临界区时，应将临界资源状态恢复为“空闲”。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>同步机制应遵循的原则：</strong></p>
<ul>
<li>空闲让进：当没有进程处于临界区时，相应的临界资源需保持为空闲状态。</li>
<li>忙则等待：当已经有进程进入临界区时，需要使得其他欲访问临界区的进程保持等待。</li>
<li>有限等待：对要访问临界资源的进程，需要保证该进程可以在有限时间内进入自己的临界区。</li>
<li>让权等待：当进程不能进入临界区时，需立即释放CPU以提高CPU利用率（例如转换到阻塞状态）。</li>
</ul>
</li>
<li><p><strong>并发进程间的直接制约关系与进程同步</strong></p>
<p>相互合作的进程需按照一定的先后顺序执行，以便顺利完成同步任务，即<strong>保证互斥</strong>和<strong>保证前驱后继关系</strong>。</p>
</li>
</ol>
<h4 id="3-4-2-进程互斥机制实现"><a href="#3-4-2-进程互斥机制实现" class="headerlink" title="3.4.2 进程互斥机制实现"></a>3.4.2 进程互斥机制实现</h4><ol>
<li><p><strong>利用硬件方法解决进程互斥：</strong></p>
<ul>
<li><p>禁止中断</p>
<p>利用系统只有在时钟中断或者其他中断处理中才会发生进程切换，采取让进程进入临界区之前禁止一切中断，使得进程切换无法发生。</p>
<p>缺点：增加系统风险、只适用于单处理器系统。</p>
</li>
<li><p>利用专用机器指令解决：</p>
<p>通过使用<strong>TSL</strong>和<strong>Swap</strong>指令，但是违背了<strong>让权等待</strong>原则（当一个进程正在等待进入某临界区时，会以空循环的方式继续消耗CPU时间），另外也可能存在<strong>饥饿现象</strong>（进程进入是随机的，有些比较重要的进程可能长时间被拒绝进入临界区）。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjgnanc7gij31340hswop.jpg" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>利用软件方法解决进程互斥：</strong></p>
<ul>
<li><p><strong>不正确的软件算法</strong></p>
<p>两个进程P0, P1共享某临界资源：设立一个标志数组flag[2]：描述进程是否已在临界区，初值均为0(FALSE)，表示进程都不在临界区。</p>
<p>该算法违背了：<strong>忙则等待</strong>和<strong>让权等待</strong>原则。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjgnklv4wyj317y0i6tmg.jpg" alt="image-20201007122252701"></p>
</li>
<li><p><strong>Peterson算法：</strong></p>
<p>该算法违背了：<strong>让权等待</strong>原则。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjgnvred0lj31l90u0nnq.jpg" alt="image-20201007123414979"></p>
</li>
<li><p><strong>面包店算法：</strong></p>
<p>面包店排队原则：按所取号码由小到大原则排队；号码相同时，按顾客名字的字典顺序排队。</p>
<p>算法描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每个进程设置一个唯一的编号Pi（i=0‥n-1） </span></span><br><span class="line"><span class="comment">boolean choosing[n]：表示进程是否正在取号，初值为False</span></span><br><span class="line"><span class="comment">int number[n]：记录每个进程取到的号码，初值为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">void  Pi()（i=0‥n-1）</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) </span><br><span class="line"> &#123;</span><br><span class="line">　   choosing[i] = True;   <span class="comment">//pi正在取号</span></span><br><span class="line">　   number[i] = <span class="number">1</span> + <span class="built_in">max</span>(Number[<span class="number">1</span>],...,Number[N]);  <span class="comment">//Pi取到的号码</span></span><br><span class="line">　   choosing [i] =False;</span><br><span class="line">　   <span class="keyword">for</span> (j=<span class="number">0</span>; j＜N; ++j) </span><br><span class="line">    &#123;</span><br><span class="line">　        <span class="keyword">while</span> (choosing[j] != <span class="number">0</span>);</span><br><span class="line">　        <span class="keyword">while</span> ((number[j]!=<span class="number">0</span>) ((number[j]＜number[i] )||((number[j] =number[i])&amp;&amp;( j＜i) ));</span><br><span class="line">           <span class="comment">//当多个进程取到同号时，保证编号小的进程优先进入临界区</span></span><br><span class="line">　   &#125;</span><br><span class="line">      临界区</span><br><span class="line">      number[i] = <span class="number">0</span>;</span><br><span class="line">      剩余区</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法违背了：<strong>让权等待</strong>原则。</p>
</li>
</ul>
</li>
<li><p><strong>利用锁机制解决进程互斥：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjgo6vgosyj310m0m0wn9.jpg" alt="image-20201007124444314"></p>
</li>
<li><p><strong>利用信号量机制解决进程互斥：</strong></p>
<ul>
<li><p><strong>记录型信号量：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">信号量数据结构：</span></span><br><span class="line"><span class="comment">value: </span></span><br><span class="line"><span class="comment">初始化为一个非负整数值，表示空闲资源总数－－若为非负值表示当前的空闲资源数，若为负值其绝对值表示当前等待临界资源的进程个数。</span></span><br><span class="line"><span class="comment">L：初值为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;<span class="comment">//信号量的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> * <span class="title">list</span>;</span> <span class="comment">//进程等待队列队首指针</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">wait()操作：</span></span><br><span class="line"><span class="comment">S最大值为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">wait(semaphore *S)</span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value&lt;<span class="number">0</span>) </span><br><span class="line">        block(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">signal()操作：</span></span><br><span class="line"><span class="comment">S最大值为-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">signal(semaphore *S)</span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;value&lt;=<span class="number">0</span>) </span><br><span class="line">        wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>利用信号量机制实现进程互斥</strong></p>
<p>为临界资源设置一个互斥信号量mutex，初值为1（亦称为互斥信号量）：即semaphore  mutex=1，在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>利用信号量机制实现进程同步</strong></p>
<p>   进程同步是指相互合作的进程之间存在某种直接制约关系，即一个进程的执行依赖于另一个进程的消息，需要进程同步，需要实现进程间相互合作的前驱后继关系。</p>
<p>   <strong>思路描述：</strong></p>
<p>   为一个同步关系设置一个同步信号量S，其初值为0：semaphore  S=0 ——表示消息（S=0表示期望的消息暂未产生）</p>
<p>   前驱进程完成操作后执行<strong>signal(S)</strong>：表示发送消息</p>
<p>   后继进程开始操作前执行<strong>wait(S)</strong>：表示等待消息到达</p>
</li>
</ul>
<h4 id="3-4-3-经典进程同步问题"><a href="#3-4-3-经典进程同步问题" class="headerlink" title="3.4.3 经典进程同步问题"></a>3.4.3 经典进程同步问题</h4><p><strong>信号量解决进程同步与互斥问题解决思路：</strong></p>
<p>（1）确定进程：包括问题中进程的数量、每个进程的工作内容等</p>
<p>（2）确定进程间的同步与互斥关系：若进程需要使用临界资源，则是互斥关系；若进程间具有前后顺序要求，则是同步关系。</p>
<p>（3）设置信号量：根据前两步骤确定信号量个数和含义以及对应的wait/signal操作，对互斥关系设置互斥信号量，初值为1，表示初始可用的临界资源为1；对同步关系设置同步信号量，初值为0，表示前驱进程暂未完成。</p>
<p>（4）用伪代码描述进程同步互斥算法。</p>
<p><strong>常见的进程同步问题：</strong></p>
<ol>
<li><p><strong>生产者—消费者问题：</strong></p>
<p><strong>问题描述：</strong></p>
<p>若干进程通过有限的共享缓冲区交换数据。其中，”生产者”进程不断写入，而”消费者”进程不断读出；共享缓冲区共有K个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjgzb9hh3bj321y0p2wxd.jpg" alt="image-20201007190944866"></p>
<p><strong>分析：</strong></p>
<ul>
<li><p><strong>确定进程：</strong>进程数量及工作内容；</p>
</li>
<li><p><strong>确定进程间的关系：</strong></p>
<p>互斥：多个进程间互斥使用同一个缓冲池；</p>
<p>同步：当缓冲池空时，消费者必须阻塞等待；当缓冲池满时，生产者必须阻塞等待。</p>
</li>
<li><p><strong>设置信号量：</strong></p>
<p>Mutex：用于访问缓冲池时的互斥，初值是1</p>
<p>Full：“满缓冲”数目，初值为0；</p>
<p>Empty：“空缓冲”数目，初值为K。full+empty=K</p>
</li>
<li><p><strong>伪代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">＃define K <span class="number">100</span></span><br><span class="line">＃define MAXLEN <span class="number">80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>  num;</span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">array</span>[MAXLEN];</span><br><span class="line">&#125;Message ;</span><br><span class="line">semaphore mutex;</span><br><span class="line">semaphore empty;</span><br><span class="line">semaphore full;</span><br><span class="line">Message buffers[K];</span><br><span class="line"><span class="keyword">int</span> in, out;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     mutex=&#123;<span class="number">1</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">     empty=&#123;K,<span class="literal">NULL</span>&#125;;</span><br><span class="line">     full=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">     Message buffers[K];</span><br><span class="line">     in =<span class="number">0</span>;  out=<span class="number">0</span>;</span><br><span class="line">     parbegin(produceri, consumerj)</span><br><span class="line">&#125;</span><br><span class="line">program  produceri</span><br><span class="line">&#123;</span><br><span class="line">  Message p_puf;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    produce a message in p_buf;</span><br><span class="line">    wait(empty)；</span><br><span class="line">    wait(mutex)；</span><br><span class="line">    buffers[in] = p_buf</span><br><span class="line">    in =( in +<span class="number">1</span>)%K;</span><br><span class="line">    signal(mutex)；</span><br><span class="line">    signal(full)；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">program  consumerj</span><br><span class="line">&#123;</span><br><span class="line">  Message c_buf;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下述两个wait语句不可以调换顺序，如果调换顺序：即 </span></span><br><span class="line"><span class="comment">    wait(mutex)；</span></span><br><span class="line"><span class="comment">    wait(full)；</span></span><br><span class="line"><span class="comment">    假设状态：mutex=1,full=0,empty=n 先执行消费者进程</span></span><br><span class="line"><span class="comment">    会先执行wait(mutex)，mutex=0，不满足block条件，执行下一句wait(full)，full=-1满足block条件，</span></span><br><span class="line"><span class="comment">    会导致无法进入临界区，而生产者因为mutex=0之后堵塞，程序陷入死锁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    wait(full)；</span><br><span class="line">    wait(mutex)；        </span><br><span class="line">    c_buf = buffers[out]；</span><br><span class="line">    out =(out+<span class="number">1</span>)%K;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下述两个signal语句可以调换顺序，但会导致临界资源mutex释放不够及时，降低了临界资源的使用效率。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    signal(mutex)；</span><br><span class="line">    signal(empty)；</span><br><span class="line">    consume the message in c_buf;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>哲学家进餐问题：</strong></p>
<p><strong>问题描述：</strong></p>
<p>有五个哲学家坐在一张圆桌旁，在圆桌上有五个盘子有五只筷子，他们的生活方式就是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时取其左右两只筷子，只有拿到这两只筷子时才能进餐；进餐完毕，放下筷子继续思考。</p>
<p>该问题解决方案较多，在此不作赘述。</p>
</li>
<li><p><strong>读者—作者问题：</strong></p>
<p><strong>问题描述：</strong></p>
<p>有多个读者进程和多个写者进程共享一数据。要求多进程对共享数据进行读写操作时，任一时刻“写者”最多只允许一个，而“读者”则允许多个，即：</p>
<ul>
<li><p>当有写者在写数据时，其他写者和读者必须等待； </p>
</li>
<li><p>当有读者在读数据时，其他写者必须等待；但其他读者可以同时读数据。</p>
</li>
</ul>
</li>
<li><p><strong>理发师问题：</strong></p>
<p><strong>问题描述：</strong></p>
<p>理发店里有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子（等候椅）。如果没有顾客，理发师便在理发椅上睡觉；第一个顾客到来时，他必须叫醒理发师；若理发师正在理发时又有顾客到达，则如果有空等候椅，顾客就坐下来等待，如果满座了就离开理发店。理发店问题经常被用来模拟各种排队情形。</p>
<p><strong>分析：</strong></p>
<ul>
<li><p><strong>确定进程：</strong>进程数量及工作内容；</p>
</li>
<li><p><strong>确定进程间的关系：</strong></p>
<p>互斥：顾客理发之间相互互斥。</p>
<p>同步：理发师工作前先查看是否有顾客，同样顾客进店时先查看有没有空位。</p>
</li>
<li><p><strong>设置信号量：</strong></p>
<p>waiting：整型变量，表示在等候椅上的顾客数，初始为0</p>
<p>cust_ready：信号量，表示理发椅上是否有顾客在等待理发，用来阻塞理发师睡觉，初值为0</p>
<p>finished：表示顾客已经完成理发，初值为0</p>
<p>chair：表示空闲的椅子数量，初值为1</p>
<p>mutex：各顾客之间理发互斥访问椅子，初值是1</p>
</li>
<li><p><strong>伪代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  waiting;</span><br><span class="line">semaphore cust_ready,finished,mutex,chair;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	waiting=<span class="number">0</span>;</span><br><span class="line">  	cust_ready=finished=<span class="number">0</span>;</span><br><span class="line">  	mutex=chair=<span class="number">1</span>;</span><br><span class="line">  	parbegin(barber,customer-i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">barber</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">  	&#123;</span><br><span class="line">     	wait(cust_ready);</span><br><span class="line">     	cut_hair;</span><br><span class="line">     	signal（finished);</span><br><span class="line">  	&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  customer-i ()  </span><br><span class="line">&#123;</span><br><span class="line">		wait(mutex)；</span><br><span class="line">    <span class="keyword">if</span>(waiting &lt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        waiting=waiting+<span class="number">1</span>;</span><br><span class="line">        signal(mutex); </span><br><span class="line">    &#125;     </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        signal(mutex)；</span><br><span class="line">        离开理发店；</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">     wait(chair);</span><br><span class="line">     sit_in_chair;</span><br><span class="line">     wait(mutex)；</span><br><span class="line">     waiting=waiting<span class="number">-1</span>;</span><br><span class="line">     signal(mutex);     </span><br><span class="line">     signal(cust_ready);</span><br><span class="line">     <span class="built_in">get</span>-haircut;</span><br><span class="line">     wait(finished);</span><br><span class="line">     stand_from_chair;</span><br><span class="line">     signal(chair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>例题：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjiwwqpdibj316g0l8qv5.jpg" alt="image-20201009111736718"></p>
<p><strong>分析：</strong></p>
<ul>
<li><p><strong>确定进程：</strong>进程数量及工作内容；</p>
</li>
<li><p><strong>确定进程间的关系：</strong></p>
<p>互斥：病人之间使用的自助挂号终端以及取药柜台。</p>
<p>同步：医生、病人、发药员。</p>
</li>
<li><p><strong>设置信号量：</strong></p>
<p>patient、call_patient、finish：semaphore</p>
<p>nurse、medicine：semaphore</p>
<p>mutex1、mutex2：semaphore</p>
</li>
<li><p><strong>伪代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  patient,call_patient,finish = <span class="number">0</span>;</span><br><span class="line">  mutex1,mutex2 = <span class="number">1</span>;</span><br><span class="line">  murse,medicine = <span class="number">0</span>;</span><br><span class="line">  parbegin(doctor,nurse,patient)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doctor</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    wait(patient);</span><br><span class="line">    signal(call_patient);</span><br><span class="line">    	给病人看病;</span><br><span class="line">    	开药方;</span><br><span class="line">    signal(finish);</span><br><span class="line">  &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nurse</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    wait(nurse);</span><br><span class="line">    	给病人拿药;</span><br><span class="line">    signal(medicine);</span><br><span class="line">  &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">patient</span><span class="params">()</span></span>&#123;</span><br><span class="line">  wait(mutex1);<span class="comment">//申请挂号端</span></span><br><span class="line">  	挂号;</span><br><span class="line">  signal(mutex1);</span><br><span class="line">  signal(patient);</span><br><span class="line">  wait(call_patient);</span><br><span class="line">  	看病;</span><br><span class="line">  wait(finish);</span><br><span class="line">  wait(mutex2);<span class="comment">//申请取药柜台</span></span><br><span class="line">  	将处方给药师;</span><br><span class="line">  signal(nurse);</span><br><span class="line">  wait(medicine);</span><br><span class="line">  	拿药;</span><br><span class="line">  signal(mutex2);</span><br><span class="line">  	离开医院;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="3-4-4-管程机制"><a href="#3-4-4-管程机制" class="headerlink" title="3.4.4 管程机制"></a>3.4.4 管程机制</h4><ol>
<li><p><strong>管程定义：</strong></p>
<p>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<p><strong>组成：</strong></p>
<ul>
<li>管程名字</li>
<li>局部于管程的共享变量的说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>初始化局部变量的语句</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li>信息隐蔽性：局部与管程的数据结构只能被管程内的过程访问；一个进程若想访问管程内的数据结构（共享资源），只能通过调用管程内某个过程实现间接访问。</li>
<li>任意时刻管程内只能有一个活跃进程。</li>
</ul>
</li>
<li><p><strong>条件变量：</strong></p>
<p>每个独立的条件变量是和进程需要等待的某种原因（或说条件）相联系的，当定义一个条件变量时，系统就建立一个相应的等待队列。</p>
</li>
</ol>
<h4 id="3-4-5-Linux同步机制"><a href="#3-4-5-Linux同步机制" class="headerlink" title="3.4.5 Linux同步机制"></a>3.4.5 Linux同步机制</h4><h3 id="3-5-进程调度"><a href="#3-5-进程调度" class="headerlink" title="3.5 进程调度"></a>3.5 进程调度</h3><h4 id="3-5-1-进程调度基本概念"><a href="#3-5-1-进程调度基本概念" class="headerlink" title="3.5.1 进程调度基本概念"></a>3.5.1 进程调度基本概念</h4><ol>
<li><p><strong>调度的层次：</strong></p>
<ul>
<li><p><strong>高级调度：</strong>又称作业调度或长程调度</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjtbsxgrqkj30r007uacb.jpg" alt="image-20201018112840812" style="zoom:80%;" />

<p><strong>考虑的问题：</strong></p>
<ul>
<li>接纳多少个作业：多道程序度</li>
<li>接纳哪些作业：作业调度算法</li>
</ul>
</li>
<li><p><strong>低级调度：</strong>又称进程调度</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjtbvfxvt6j30sm06wwgl.jpg" alt="image-20201018113105242" style="zoom:80%;" />

<p><strong>考虑的问题：</strong></p>
<ul>
<li>调度标准：进程调度算法</li>
<li>调度时机：什么时候调度</li>
</ul>
</li>
<li><p><strong>中级调度：</strong></p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjtbxl44g2j30x208umzx.jpg" alt="image-20201018113302434" style="zoom:80%;" />

<p>引人中级调度的主要目的是为了提高<strong>内存利用率</strong>和<strong>系统吞吐量</strong>。</p>
<p><strong>考虑的问题：</strong></p>
<ul>
<li>交换哪些进程</li>
<li>什么时候交换</li>
</ul>
</li>
<li><p><strong>三级调度示意图：</strong></p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjtc04e6j2j31340egwha.jpg" alt="image-20201018113529832" style="zoom:80%;" />
</li>
</ul>
</li>
<li><p><strong>进程调度方式：</strong></p>
<ul>
<li>非抢占方式：一旦进程占用CPU就一直运行，直到终止或等待。</li>
<li>抢占方式：系统强行剥夺已分配给现运行进程的CPU，而重新分   配给其他进程运行。</li>
<li>抢占原则：时间片原则；优先权原则；还需要的运行时间等。</li>
</ul>
</li>
<li><p><strong>进程调度时机：</strong></p>
<ul>
<li>当前运行进程已完成所有工作而结束，或因为某种错误而被终止运行</li>
<li>当前进程因为需要等待某事件发生而转变为阻塞状态</li>
<li>分时系统中时间片用完</li>
<li>采取基于优先级的抢占方式调度，当就绪队列出现优先级更高的就绪进程</li>
<li>系统完成系统调用或中断处理后，在返回到用户态之前通常会产生一次调度时机</li>
</ul>
</li>
<li><p><strong>调度性能的评价指标：</strong></p>
<ul>
<li><p>CPU的利用率</p>
</li>
<li><p>系统吞吐量</p>
</li>
<li><p>周转时间和带权周转时间</p>
<ul>
<li><p>周转时间：从作业提交给系统到作业处理完成所经历的时间<br>$$<br>T=\frac{1}{n}\sum_{i=1}^n T_i<br>$$</p>
</li>
<li><p>带权周转时间：作业的周转时间T与系统为它提供服务的时间Ts之比，即W=T/Ts，称为带权周转时间。<br>$$<br>W=\frac{1}{n}\sum_{i=1}^n \frac{T_i}{T_{si}}<br>$$</p>
</li>
</ul>
</li>
<li><p>响应时间</p>
</li>
<li><p>截止时间</p>
</li>
</ul>
</li>
</ol>
<h4 id="3-5-2-进程调度算法"><a href="#3-5-2-进程调度算法" class="headerlink" title="3.5.2 进程调度算法"></a>3.5.2 进程调度算法</h4><ol>
<li><p><strong>先来先服务调度算法（FCFS）：</strong></p>
<p>优先选择驻留时间最久的进程。</p>
<p>优点：实现简单</p>
<p>缺点：对长作业有利，对短作业不利；平均周转时间可能较长；没有考虑任务的紧迫性</p>
</li>
<li><p><strong>短作业优先调度算法：（SJF）</strong>：</p>
<p>优先选择下一次估计运行时间最短的进程。</p>
<p>优点：使作业的平均周转时间最短；可以证明：对于一组同时到达的作业，采用SJF算法将得到一个最小的平均周转时间。</p>
<p>缺点：对长作业不利（饥饿状态）；对紧迫作业不利 ；估计运行时间不准，难以真正做到短作业（进程）优先。</p>
</li>
<li><p><strong>高响应比优先调度算法（HRRF）：</strong><br>$$<br>响应比=\frac{要求服务时间+等待时间}{要求服务时间}=1+\frac{等待时间}{要求服务时间}<br>$$<br>高响应比调度算法一般选择非抢占式。</p>
<p>优点：</p>
<pre><code>首先照顾了短作业；</code></pre><p>​    同时也考虑了长作业的等待时间，相对比较公平。<br> 缺点：</p>
<p>​    每次调度都需要重新计算所有作业或就绪进程的响应比，系统开销较大；常采用非抢占调度方式。</p>
<p>​    不能保证紧迫型任务得到及时处理。</p>
</li>
<li><p><strong>优先级调度算法：</strong></p>
<ul>
<li>优先级进程调度算法的类型<ul>
<li>非抢占式优先级调度算法</li>
<li>抢占式优先级调度算法（<strong>计算平均周转时间时注意记录开始时间和截止时间</strong>）</li>
</ul>
</li>
<li>优先级的设计方法：<ul>
<li>静态优先级</li>
<li>动态优先级</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>时间片轮转调度算法：（RR）</strong></p>
<p>主要用于分时系统的进程调度，系统将所有的就绪进程按FCFS原则排成一个就绪队列，每次调度时把CPU分给队首进程，令其运行一个时间片（<strong>时间片固定分给对应的进程</strong>），时间片到了之后运行未结束，就将其插入就绪队列末尾等待下一次CPU调度。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjtd67n1pvj312c074dje.jpg" alt="image-20201018121602881"></p>
<p><strong>时间片大小的确定：</strong></p>
<p>T(系统响应时间)=N(就绪队列中进程数) x q(时间片)</p>
</li>
<li><p><strong>多级队列调度算法：</strong></p>
<ul>
<li>系统中设置多个就绪队列，每个队列优先级不同</li>
<li>每个队列有自己独立的进程调度算法</li>
<li>一个进程依据其属性固定位于某个就绪队列中</li>
</ul>
</li>
<li><p><strong>多级反馈队列调度算法：</strong></p>
<ul>
<li>设置多个就绪队列，并给各个队列赋予不同的优先级</li>
<li>各个队列内部按照时间片轮转算法调度</li>
<li>各队列之间采取抢占式优先级算法调度</li>
</ul>
</li>
</ol>
<h4 id="3-5-3-Linux进程调度"><a href="#3-5-3-Linux进程调度" class="headerlink" title="3.5.3 Linux进程调度"></a>3.5.3 Linux进程调度</h4><h3 id="3-6-进程通信"><a href="#3-6-进程通信" class="headerlink" title="3.6 进程通信"></a>3.6 进程通信</h3><h4 id="3-6-1-进程通信类型"><a href="#3-6-1-进程通信类型" class="headerlink" title="3.6.1 进程通信类型"></a>3.6.1 进程通信类型</h4><ol>
<li><p><strong>共享存储器系统通信：</strong></p>
<p>通过对共享存储区的读写操作实现进程通信。</p>
<p><strong>具体过程：</strong></p>
<p>(1)申请共享存储分区<br>(2)将共享存储分区映射到本进程地址空间中<br>(3)进行数据读写<br>(4)解除共享存储分区映射<br>(5)删除共享存储分区</p>
<p><strong>特点：</strong></p>
<p>（1）最大的特点是没有中间环节，直接把共享内存映射到不同进程的虚拟地址空间中，进程可直接进行访问，通信直接快速。</p>
<p>（2）该通信机制没有提供进程同步机制。</p>
</li>
<li><p><strong>消息传递系统通信：</strong></p>
<ul>
<li>直接通信方式：send()&amp;receive()</li>
<li>间接通信方式：通信双方利用一个共享的称为信箱的中间实体实现信息交换。</li>
</ul>
</li>
<li><p><strong>管道通信：</strong></p>
<p><strong>基本原理：</strong></p>
<p>管道：用于连接一个发送进程和一个接收进程，以实现它们之间通信的共享文件（pipe文件，又称为FIFO文件）</p>
<p>FIFO文件的写入和读出：严格遵循先进先出，不支持文件定位操作。</p>
<p><strong>实现机制：</strong></p>
<ul>
<li><p>无名管道：</p>
<p>无名管道存在于高速缓存中的临时文件，没有对应的磁盘映像，常用于有亲缘关系进程之间的通信，关闭后管道文件不复存在。</p>
</li>
<li><p>有名管道：</p>
<p>可用于任意进程之间的通信，可以在文件系统中长期存在的具有路径名的文件。</p>
</li>
<li><p><strong>应注意的问题：</strong></p>
<p>对管道的读<strong>与</strong>写操作必须互斥进行</p>
<p>对管道的读<strong>或</strong>写操作必须同步进行</p>
<p>通信双方必须同时存在</p>
</li>
</ul>
</li>
<li><p><strong>客户-服务器系统通信：</strong></p>
</li>
</ol>
<h4 id="3-6-2-消息缓冲队列通信机制"><a href="#3-6-2-消息缓冲队列通信机制" class="headerlink" title="3.6.2 消息缓冲队列通信机制"></a>3.6.2 消息缓冲队列通信机制</h4><ol>
<li><p>基本实现逻辑：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc72nguqsj30xi0a8h0l.jpg" alt="image-20201103191031518"></p>
</li>
<li><p>相关数据结构：</p>
<ul>
<li>消息缓冲区</li>
<li>消息缓冲区队列</li>
<li>与通信有关的数据项</li>
</ul>
</li>
<li><p>发送原语send()</p>
<ul>
<li>申请空白消息缓冲区</li>
<li>填写该空白消息缓冲区</li>
<li>将该消息缓冲区挂到接收进程的消息队列上</li>
</ul>
</li>
<li><p>接收原语receive()</p>
<ul>
<li>从当前消息队列中取出指定的消息缓冲区</li>
<li>把该消息缓冲区信息复制到接受区b</li>
<li>释放该消息缓冲区</li>
</ul>
</li>
</ol>
<h3 id="第三章练习题"><a href="#第三章练习题" class="headerlink" title="第三章练习题"></a>第三章练习题</h3><ol>
<li><p>并发进程失去封闭性，是指（并发进程执行时，可能会共享系统中的某些资源）。</p>
</li>
<li><p>并发进程的（异步性），是指多个相对独立的进程以各自的速度向前推进。</p>
</li>
<li><p>多个进程在处理器上执行时，具有并发性，即同时执行的特征。（❌）</p>
</li>
<li><p>多个进程在处理器上执行时，进程之间是无关的，具有封闭性。（❌）</p>
</li>
<li><p>进程是指令的集合。（❌ 程序是指令的集合）</p>
</li>
<li><p>Linux系统在撤销一个进程的过程中，将同时撤销其所有子进程，因此进程撤销所需要的时间较长。（❌）（会为子进程重新找一个临时父进程）</p>
</li>
<li><p>子进程可以继承其父进程所拥有的所有资源。（❌）（只能继承程序和数据，但栈区和PCB是自己的）</p>
</li>
<li><p>在Linux的shell中输入一个命令时，shell会创建一个新进程来执行这个命令。（✅）</p>
</li>
<li><p>进程切换是指CPU调度不同的进程执行，当一个进程从（运行状态变为就绪状态）时，CPU调度另一个进程执行，引起进程切换。</p>
</li>
<li><p>UNIX系统中进程的进程控制块中常驻内存的是（proc结构）。</p>
</li>
<li><p>用户编写的C程序中的自动变量位于进程映像的（用户栈）部分。</p>
</li>
<li><p>进程自身决定(A)。</p>
<p>A．从运行状态到阻塞状态    B．从运行状态到就绪状态    C．从就绪状态到运行状态    D．从阻塞状态到就绪状态</p>
<p><strong>只有从运行状态到阻塞状态的转换是由进程自身决定的。</strong>从运行状态到就绪状态的转换是由于进程的时间片用完，“主动”调用程序转向就绪状态。虽然从就绪状态到运行状态的转换同样是由调度程序决定的，但是进程是“被动的”。从阻塞状态到就绪状态的转换是由协作进程决定的。</p>
</li>
<li><p>通常用户进程被建立后(B)。</p>
<p>A．便一直存在于系统中，直到被操作人员撤销</p>
<p>B．随着进程运行的正常或不正常结束而撤销</p>
<p>C．随着时间片轮转而撤销与建立</p>
<p>D．随着进程的阻塞或者唤醒而撤销与建立</p>
<p>进程不会一直存在于系统中，也不一定需要用户显式地撤销。<strong>进程在时间片结束时只是阻塞，而不是撤销。</strong>阻塞和唤醒是进程生存期的中间状态。</p>
</li>
<li><p>当一个进程处于（A）状态时，称其为等待（或阻塞）状态。</p>
<p>A．它正等待输入一批数据    B．它正等待进程调度    C．它正等待分给它一个时间片    D．它正等待进入内存</p>
</li>
<li><p>若某单处理机多进程系统中有多个就绪进程，则下列关于处理机调度的叙述中，正确的有哪些？（ABD）<br>A.   在进程结束时能进行处理机调度<br>B.   创建新进程后能进行处理机调度<br>C.   在进程处于临界区时不能进行处理机调度<br>D.   在系统调用完成并返回用户态时能进行处理机调度</p>
</li>
<li><p>有3个作业J1，J2，J3，其运行时间分别是2,6,4小时，假设它们同时到达系统，并在同一处理器上以单道方式运行，则平均周转时间最小的执行序列是（J1-J3-J2）。</p>
<p>SJF:(2+2+4+2+4+6)/3</p>
</li>
<li><p>下列选项中，提升进程优先级的合理时机有（BCEF）。<br>A．进程时间片用完         B. 进程刚完成I/O操作，进入就绪队列</p>
<p>C. 进程长期处于就绪队列中     D. 进程从就绪状态转为运行状态</p>
<p>E. 刚创建完成的新进程     F. 刚被V操作唤醒的进程</p>
<p>G. 当进行进程调度时，提升就绪队列中进程的优先级</p>
</li>
<li><p>（FCFS）有利于CPU繁忙型的作业，而不利于<strong>I/O繁忙型（I/O繁忙型作业通常每次计算时间较短）</strong>的作业。</p>
</li>
<li><p>在非剥夺调度方式下，运行进程执行V原语之后，其状态（不变）。</p>
</li>
<li><p>==某系统中有4个进程：A、B、C、D，其运行时间分别为6ms，3ms，1ms，7ms，均在时刻0到达系统，到达的顺序为A、B、C、D，若采用时间片轮转调度算法，时间片长度为3，则平均周转时间是（10.75）。==</p>
</li>
<li><p>某系统中有4个进程：A、B、C、D，其运行时间分别为6ms，3ms，1ms，7ms，均在时刻0到达系统，到达的顺序为A、B、C、D，若采用短进程优先调度算法，则平均周转时间是（8ms）。</p>
</li>
<li><p>下列调度算法中，（时间片调度）调度算法是绝对可抢占的。</p>
</li>
<li><p>时间片轮转调度算法是为了(多个终端能够得到系统及时响应)。</p>
</li>
<li><p>下列关于管道（Pipe）通信的叙述中，正确的是（A）</p>
<p>A.进程对管道进行读操作和写操作都可能被阻塞</p>
<p>B.一个管道只能有一个进程或一个写进程对其操作</p>
<p>C.一个管道可实现双向数据传输</p>
<p>D.管道的容量仅受磁盘容量大小限制</p>
<p>E.当通信双方进程被撤销时，会同时删除它们所创建的管道</p>
<p>解答：A.正确，因为管道为空，读操作会被阻塞；管道满了，写操作会被阻塞  B.可以有多个进程对其读；也可以有多个进程写，只不过不能同时写。并且题目没有说“同时”，B不对   C.匿名管道只能单向；命名管道可以双向；所以C过于绝对  D.管道是内存中的，所以D不对  E：只有无名管道会被删除，有名管道会永久存在</p>
</li>
</ol>
<h2 id="第四章：存储器管理"><a href="#第四章：存储器管理" class="headerlink" title="第四章：存储器管理"></a>第四章：存储器管理</h2><h3 id="4-1-存储器管理概述"><a href="#4-1-存储器管理概述" class="headerlink" title="4.1 存储器管理概述"></a>4.1 存储器管理概述</h3><ul>
<li><p><strong>存储器管理功能：</strong></p>
<ul>
<li><p>内存分配与回收：静态/动态分配与回收</p>
</li>
<li><p>地址映射：将相对地址（虚地址）映射至绝对地址，亦称为地址重定位。</p>
</li>
<li><p>内存共享与保护：</p>
<ul>
<li><p><strong>采用界地址寄存器</strong></p>
<p>在系统中设置上下界寄存器，分别用来存放当前运行进程在内存的末地址和起始地址，根据程序的物理地址与两个寄存器值进行比较。</p>
</li>
<li><p><strong>采用重定位寄存器+限长寄存器</strong></p>
<p>将当前进程的长度存放在限长寄存器中，进行越界检查时仅需要将逻辑地址同限长寄存器的值进行比较。</p>
</li>
</ul>
</li>
<li><p>内存扩充：采用虚拟存储器进行扩充</p>
</li>
</ul>
</li>
<li><p><strong>程序的装入和链接：</strong></p>
<ul>
<li><p>程序链接方式：</p>
<p>将编译后的若干模块进行链接形成装入程序，有如下三种方式：</p>
<ul>
<li>静态链接：在装入内存前将目标模块与库模块连接成<strong>一个完整的可执行程序</strong>。</li>
<li>装入时动态链接：<strong>完整程序</strong>装入内存时边装入边链接，下一次运行时会在装入时重新链接。</li>
<li>运行时动态链接：程序待使用某模块时<strong>才</strong>装入链接该程序。</li>
</ul>
</li>
<li><p>程序装入方式：</p>
<p>将装入程序装入内存时进行地址映射的方式，有如下三种方式：</p>
<ul>
<li>绝对装入：直接将对应的逻辑地址转换成指定物理地址装入内存，即<strong>该地址在编译时已经确定</strong>，仅适用于单道程序环境。</li>
<li>静态重定位装入：程序装入前根据<strong>装入程序</strong>进行地址映射，将当前的逻辑地址映射为物理地址后装入内存，适用于多道批处理操作系统，作业在装入内存时要分配全部内存空间。</li>
<li>动态重定位装入：程序仅将<strong>真正执行的</strong>模块装入内存，根据专门的<strong>地址映射机构</strong>（重定位寄存器）进行地址映射。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-连续存储器管理方式"><a href="#4-2-连续存储器管理方式" class="headerlink" title="4.2 连续存储器管理方式"></a>4.2 连续存储器管理方式</h3><p>连续存储器管理方式就是为进程分配一段连续的物理内存空间，也就是将一维线性连续的虚地址空间映射到一维线性连续的实地址空间的方法。主要分为如下两种：</p>
<h4 id="4-2-1-固定分区方式"><a href="#4-2-1-固定分区方式" class="headerlink" title="4.2.1 固定分区方式"></a>4.2.1 固定分区方式</h4><ul>
<li><p><strong>基本原理</strong></p>
<ul>
<li>物理内存空间被划分为大小和数量都固定的若干分区</li>
<li>每个分区只能装入一个程序<ul>
<li>分区大小相同</li>
<li>分区大小不同</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实现方式</strong></p>
<p>使用分区分配表和相应的分配回收算法实现，程序装入方式采取<strong>静态重定位</strong>方式，一次完成地址映射后日后不会改变地址。</p>
</li>
<li><p><strong>缺点</strong></p>
<p>分区数量和位置固定，导致分区内部存在空间浪费，产生内部碎片，降低了内存利用率</p>
<ul>
<li>内部碎片：已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间——单道连续分配</li>
<li>外部碎片：还没有被分配出去（不属于任何进程），但是由于太小导致无法分配给新进程——多道可变连续分配</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-可变分区方式"><a href="#4-2-2-可变分区方式" class="headerlink" title="4.2.2 可变分区方式"></a>4.2.2 可变分区方式</h4><p>可变分区方式使用空闲分区链和相应的分配回收算法实现：</p>
<ul>
<li><p>分配算法</p>
<ul>
<li><p>首次适应算法</p>
<p>该算法要求空闲分区链按各空闲分区的<strong>起始地址递增</strong>的顺序链接，此算法倾向于多分配，使用低端内存区域便于高端内存留下较大的连续内存空间，但是容易产生外部碎片。</p>
</li>
<li><p>最佳适应算法</p>
</li>
<li><p>最坏适应算法</p>
</li>
</ul>
</li>
<li><p>回收算法</p>
<ul>
<li><p>上邻接</p>
</li>
<li><p>下邻接</p>
</li>
<li><p>上下邻接</p>
<p>待回收分区R在低端地址与空闲分区F1相邻，同时高端地址与空闲分区F2相邻，回收时分区起始地址为F1，F2分区节点从空闲分区链删除，使得空闲分区数量减1。</p>
</li>
<li><p>无邻接</p>
<p>待回收分区R不与任何空闲分区相邻，回收时需重新创建新的空闲分区节点，同时空闲分区数量加1。</p>
</li>
</ul>
</li>
</ul>
<p>连续存储管理方式会产生碎片，通过采取“紧凑”的方式使得不连续空间变为连续空间，从而消除碎片。</p>
<h3 id="4-3-分页存储管理方式"><a href="#4-3-分页存储管理方式" class="headerlink" title="4.3 分页存储管理方式"></a>4.3 分页存储管理方式</h3><p>现代操作系统使用非连续存储管理方式实现进程装载到不连续的内存空间中，常用的管理方式有分页存储管理方式、分段存储管理方式、段页式存储管理方式。</p>
<h4 id="4-3-1-分页存储管理基本原理"><a href="#4-3-1-分页存储管理基本原理" class="headerlink" title="4.3.1 分页存储管理基本原理"></a>4.3.1 分页存储管理基本原理</h4><ul>
<li><p><strong>页与页框：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmstuvslo2j31r90u04qp.jpg" alt="image-20210119110844127"></p>
</li>
<li><p><strong>逻辑地址结构：</strong></p>
<p>逻辑地址结构包含如下两部分：</p>
<ul>
<li>页号：页号位数决定了逻辑地址空间中页面的总数。 <strong>页号=逻辑地址/页面大小</strong></li>
<li>页內地址（页內偏移量）：页面的大小决定了页內地址的位数。 <strong>页內地址=逻辑地址%页面大小</strong></li>
</ul>
</li>
<li><p><strong>页表：</strong>用来存放起始块号</p>
<p>页表是一张页号到物理块号的映射表，页表的每个表项PTE由页号P和对应的物理块号F组成，页表存储在内存中，且只存储物理块号F，不存储页号P，然后将页表的起始地址及长度存放在进程对应的页表寄存器中（PCB）。</p>
</li>
<li><p><strong>地址映射与越界保护：</strong>（计算条件不需要知道页号，仅凭借页面大小和对应的逻辑块号即可计算）</p>
<p><strong>物理地址=页面对应的物理块号x页面大小+页內偏移量</strong></p>
<p>借助地址映射机构完成相关地址映射以及越界检查。</p>
<p>⚠️注意：<strong>越界中断条件</strong>是页号&gt;=页表长度，（页号从0开始，但页表长度至少为1） </p>
</li>
<li><p><strong>快表：</strong>在地址映射机构中添加TLB，TLB存放在Cache中，以此来加快查询速度。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmsve0wls9j31ve0dm173.jpg" alt="image-20210119120147573"></p>
</li>
</ul>
<h4 id="4-3-2-两级和多级页表"><a href="#4-3-2-两级和多级页表" class="headerlink" title="4.3.2 两级和多级页表"></a>4.3.2 两级和多级页表</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmsw026k5bj31n50u0b29.jpg" alt="image-20210119122257786"></p>
<h3 id="4-4-分段存储管理方式"><a href="#4-4-分段存储管理方式" class="headerlink" title="4.4 分段存储管理方式"></a>4.4 分段存储管理方式</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmsw4nx8xzj31ik0kkaq9.jpg" alt="image-20210119122723417"></p>
<p><strong>⚠️注意有两次越界中断检查</strong></p>
<p>分段分页式对比：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmswfqa6jtj31r20u0e81.jpg" alt="image-20210119123801600"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmswh5easfj31vu0buwvg.jpg" alt="image-20210119123923264"></p>
<h3 id="4-5-段页式存储管理方式"><a href="#4-5-段页式存储管理方式" class="headerlink" title="4.5 段页式存储管理方式"></a>4.5 段页式存储管理方式</h3><p>  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmswjluh8lj31ov0u0hdt.jpg" alt="image-20210119124127550"></p>
<h3 id="4-6-虚拟存储系统"><a href="#4-6-虚拟存储系统" class="headerlink" title="4.6 虚拟存储系统"></a>4.6 虚拟存储系统</h3><h4 id="4-6-1-虚拟存储器的基本概念"><a href="#4-6-1-虚拟存储器的基本概念" class="headerlink" title="4.6.1 虚拟存储器的基本概念"></a>4.6.1 虚拟存储器的基本概念</h4><ul>
<li><p><strong>基本定义：</strong></p>
<p>虚拟存储器是指具有请求调入功能和置换功能，能够利用外存空间从逻辑上扩充内存容量的一种存储器系统。</p>
</li>
<li><p><strong>实现方式：</strong></p>
<p>基于主存容量不满足应用需求，利用程序局部性原理：时间局部性和空间局部性，基本实现方式有三种，分别是：<strong>请求分页</strong>、请求分段和请求段页式。</p>
<ul>
<li>程序的全部代码和数据存放在辅存中；</li>
<li>程序当前执行所涉及的那部分程序代码放入主存中；</li>
<li>程序执行时，当所需信息不在主存，由操作系统和硬件配合来从辅存中调入信息，程序继续执行。</li>
</ul>
</li>
<li><p><strong>特征：</strong></p>
<ul>
<li><p>多次性</p>
<p>将进程装入的一次性或整体性变为多次性</p>
</li>
<li><p>置换性</p>
<p>将进程的驻留性改为置换性</p>
</li>
<li><p>虚拟性</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-6-2-请求分页存储管理方式"><a href="#4-6-2-请求分页存储管理方式" class="headerlink" title="4.6.2 请求分页存储管理方式"></a>4.6.2 请求分页存储管理方式</h4><p>基本实现方式：在基本分页存储管理系统上增加了请求调页功能和页面置换功能，使用带有缺页中断机构的地址映射机构实现逻辑地址到物理地址的转换过程。</p>
<ol>
<li><p><strong>页表：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glm2k4frjfj31e00iuql9.jpg" alt="image-20201213113029227"></p>
<ul>
<li><p>状态位：进行地址转换选择</p>
</li>
<li><p>访问位：进行页面淘汰选择</p>
</li>
<li><p>修改位：页面淘汰情况下，优先选择未被修改的；若被修改必须将页面换到外存上。</p>
<p>1）状态位P:用于指示该页是否已调入内存，供程序访问时参考； </p>
<p>2）访问字段A:用于记录本页在一段时间内被访问次数，供选择换出页面时参考； </p>
<p>3）修改位M：表示该页在调入内存后是否被修改过，供置换页面时参考； </p>
<p>4）外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考；</p>
</li>
</ul>
</li>
<li><p><strong>缺页中断机构：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glm371cvs7j30z00pwqfg.jpg" alt="image-20201213115233780"></p>
</li>
</ol>
<p>   例题：某请求分页系统中，若其指令系统指令长16位，每个操作数的地址码长6位，操作码4位，每个操作数16位，则执行一条双操作数指令，则最多可能发生几次缺页中断？<strong>指令+2个操作数 = 2*3 =6次</strong></p>
<ol start="3">
<li><p><strong>地址映射机构：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glm3aialq7j316e0sk7m0.jpg" alt="image-20201213115531230"></p>
</li>
<li><p><strong>页面置换策略：</strong></p>
<p>根据是否“可变”和是否“全局”可分为如下三种：</p>
<ul>
<li>固定分配局部置换</li>
<li>可变分配全局置换</li>
<li>可变分配局部置换（同固定分配局部置换不同，当发现经常出现缺页，会重新增加<strong>工作集</strong>）</li>
</ul>
<p>其中<strong>可变</strong>指的是进程分配的内存物理块数量可以变化，<strong>全局</strong>指的是进程置换页面的时候可以从内存所有页面（所有进程）进行置换，<strong>局部</strong>指的是进程置换页面只能从本身已存在（当前进程）内存的页面中选择置换。</p>
</li>
<li><p><strong>页面置换算法：</strong></p>
<ul>
<li><p>最佳置换算法（OPT）</p>
<p>选择将来永远不会再访问的页面或最长时间内不会访问的页面进行淘汰，因OS无法提前知晓后续走向，所以该算法仅仅是理论上的算法。</p>
</li>
<li><p>先进先出算法（FIFO）</p>
<p>选择淘汰最先调入内存的页面，或是在内存驻留时间最久的页面，该算法简单易实现，但性能较差，易产生Belady异常，有较高的缺页率。</p>
</li>
<li><p>最近最久未使用置换算法（LRU）</p>
<p>选择淘汰最近一段时间内<strong>最长时间</strong>没有被访问的页面（即逆向检查在内存中的页面号，最后一个出现的即要淘汰的），该算法利用局部性特征使得性能较为接近于OPT，但如果出现经常访问较长时间以前曾经访问过的页面，LRU的缺页率就会变高。同时该算法实现难度较高。</p>
</li>
<li><p>最近最少使用算法（LFU）</p>
<p>选择淘汰过去一段时间里访问<strong>次数</strong>最少的页面，同LRU都是基于堆栈型的置换算法，不同于FIFO是基于队列实现。</p>
</li>
<li><p>简单时钟（CLOCK）置换算法（NRU）</p>
<p>给每个页面关联一个访问位U，用以记录该界面过去一段时间中被访问的情况，将所有页面组织成循环队列，设置替换指针，让其始终指向最近被淘汰的页面所在的物理块块号。（移动指针指向下一个页面！！）</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glm4vyt9hqj30wq0ru41e.jpg" alt="image-20201213125108164"></p>
</li>
<li><p>改进时钟（CLOCK）置换算法</p>
<p>在上述算法中增加访问位A、修改位M，分别表示页面的四种状态：</p>
<ul>
<li>00： (A=0;M=0)最近未被访问也未被修改</li>
<li>01： (A=0;M=1)最近未被访问但已被修改</li>
<li>10： (A=1;M=0)最近已被访问但未被修改</li>
<li>11： (A=1;M=1)最近已被访问且被修改</li>
</ul>
<p>扫描方式：</p>
<p>第一轮：查找A=0,M=0页面，未找到，下一步；</p>
<p>第二轮：查找A=0,M=1页面，未找到，下一步；</p>
<p>第三轮：把所有A置为“0”，重复第一轮，必要时再重复第二轮。</p>
</li>
</ul>
</li>
<li><p><strong>页缓冲思想：</strong>可变分配局部置换策略</p>
</li>
</ol>
<h3 id="第四章练习题"><a href="#第四章练习题" class="headerlink" title="第四章练习题"></a>第四章练习题</h3><ol>
<li><p>请求分页存储管理中发生的缺页中断属于（程序中断）</p>
</li>
<li><p>在虚拟存储系统中，完成地址转换工作的是（<strong>硬件</strong>）！！！</p>
</li>
<li><p><strong>理论上虚拟内存的最大容量只受（计算机的地址位数）的限制  ？？？</strong></p>
</li>
<li><p>系统“抖动”现象发生的原因是（置换算法选择不当）</p>
</li>
<li><p>在请求分页存储管理系统中，若把页面大小增加一倍，则进程页面数量会减少一半，从而使缺页中断次数也减少一半（❌）。</p>
</li>
<li><p>在段式存储管理方式中，为了让两个不同的进程共享同一代码段，下面方法正确的是（让进程各自的段表项拥有共享段的相同的段始址和段长度）。</p>
</li>
<li><p>如果希望程序能方便的进行动态链接，则下面内存管理方法中最最有利的是（分段存储管理）。</p>
</li>
<li><p>段页式存储管理吸取了页式管理和段式管理的长处，其实现原理结合了页式和段式管理的基本思想，即（用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间）。</p>
</li>
<li><p>进程执行时发生了缺页中断，中断处理完成后应执行（被中断的指令）。</p>
</li>
<li><p>测得某个采用按需调页策略的计算机系统部分状态数据为：CPU利用率20%，用于交换空间的磁盘利用率97.7%，其他设备的利用率5%。由此判断系统出现异常，这种情况下(D)能提高系统性能。</p>
<p>A．安装一个更快的硬盘    B．通过扩大硬盘容量增加交换空间    C．增加运行进程数    D．加内存条来增加物理空间容量</p>
<p>用于交换空间的磁盘利用率已达到97.7%，其他设备利用率5%，CPU利用率20%，说明在任务作业不多的情况下交换操作非常频繁，故判断物理内存严重短缺。</p>
</li>
<li><p>下列存储分配方案中可能使系统抖动的有（D）。<br>Ⅰ．动态分区分配；Ⅱ．简单页式；Ⅲ．虚拟页式；Ⅳ．简单段页式；Ⅴ．简单段式；Ⅵ．虚拟段式</p>
<p>A．Ⅰ和Ⅱ    B．Ⅱ和Ⅳ    C．Ⅴ和Ⅵ    D．Ⅲ和Ⅵ</p>
<p>“抖动”现象是指刚刚被换出的页很快又要被访问，为此，又要换出其他页，而该页又很快被访问，如此频繁地置换页面，以致大部分时间都花在页面置换上。对换的信息量过大，内存容量不足不是引起系统抖动现象的原因，而选择的置换算法不当才是引起抖动的根本原因，例如，先进先出算法就可能会产生抖动现象。本题中只有虚拟页式和虚拟段式才存在换入换出的操作，简单页式和简单段式因已经全部将程序调入内存，因此不需要置换，也就没有了抖动的现象。故正确答案为D。</p>
</li>
<li><p>设主存容量为1MB，外存容量为400MB，计算机系统的地址寄存器有24位，那么虚存的最大容量为（16MB）</p>
</li>
<li><p>已知一个虚拟页式存储系统，内存实地址有32位，采用48位虚拟地址，页面大小为4KB，页表项大小为8B，则要采用(4) 级页表，页内偏移为(12) 位。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm53wjuxbgj30z005saco.jpg" alt="image-20201229224247606"></p>
</li>
<li><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm53xch547j31110u0gus.jpg" alt="image-20201229224326288" style="zoom:50%;" />
</li>
<li><p>程序空间页的大小与计算机物理块的大小总是一致的（✅）</p>
</li>
</ol>
<h2 id="第五章：设备管理"><a href="#第五章：设备管理" class="headerlink" title="第五章：设备管理"></a>第五章：设备管理</h2><h3 id="5-1-设备管理的功能"><a href="#5-1-设备管理的功能" class="headerlink" title="5.1 设备管理的功能"></a>5.1 设备管理的功能</h3><ul>
<li><p><strong>设备分配：</strong></p>
<p>根据用户的I/O请求以及系统当前的资源情况进行分配，分为动态分配和静态分配两种方式。</p>
</li>
<li><p><strong>缓冲管理：</strong></p>
<p>缓冲CPU和I/O设备间速度不匹配的矛盾，提高CPU和I/O的并行性。</p>
</li>
<li><p><strong>设备处理：</strong></p>
<p>对物理设备进行控制，由<strong>设备驱动程序</strong>和<strong>中断处理程序</strong>实现真正的IO操作。</p>
</li>
</ul>
<p>设备管理的目的是提高设备利用率，方便用户使用。</p>
<h3 id="5-2-输入-输出系统"><a href="#5-2-输入-输出系统" class="headerlink" title="5.2 输入/输出系统"></a>5.2 输入/输出系统</h3><h4 id="5-2-1-设备的分类"><a href="#5-2-1-设备的分类" class="headerlink" title="5.2.1 设备的分类"></a>5.2.1 设备的分类</h4><ul>
<li><strong>数据传输速率：</strong>高速设备（磁带机）、中速设备、低速设备</li>
<li><strong>信息交换单位：</strong>块设备、字符设备</li>
<li><strong>设备共享属性：</strong>独占设备、共享设备（CD-ROM）、虚拟设备</li>
<li><strong>工作特性：</strong>存储设备、I/O设备</li>
</ul>
<h4 id="5-2-2-设备控制器"><a href="#5-2-2-设备控制器" class="headerlink" title="5.2.2 设备控制器"></a>5.2.2 设备控制器</h4><ul>
<li><p><strong>设备控制器的功能：</strong></p>
<p>接受CPU命令，控制相应I/O设备，以实现IO设备和计算机之间的数据交换工作，主要功能如下：</p>
<ul>
<li>接受和识别命令</li>
<li>数据交换</li>
<li>地址识别</li>
<li>数据缓冲</li>
<li>识别和报告设备状态</li>
<li>差错控制</li>
</ul>
</li>
<li><p><strong>设备控制器的组成：</strong></p>
<ul>
<li>设备控制器与处理器的接口：<strong>系统接口</strong></li>
<li>设备控制器与设备的接口：<strong>设备接口</strong></li>
<li>I/O逻辑（通过<strong>I/O逻辑</strong>实现对<strong>设备</strong>的控制）</li>
</ul>
</li>
</ul>
<h4 id="5-2-3-I-O通道"><a href="#5-2-3-I-O通道" class="headerlink" title="5.2.3 I/O通道"></a>5.2.3 I/O通道</h4><ul>
<li><p><strong>I/O通道的引入：</strong></p>
<p>为减少CPU对I/O的干预，在CPU和设备控制器之间引入新的设备——<strong>通道</strong>，以此来实现独立于CPU进行I/O操作，即I/O通道是一种独立出来的专门负责输入输出工作的<strong>专用处理器</strong>，同CPU共享内存（即没有自己的内存）。</p>
</li>
<li><p><strong>通道类型：</strong></p>
<ul>
<li>字节多路通道：以<strong>字节</strong>为单位传输信息，采取<strong>TDM</strong>可同时执行多个通道程序，常用于低速或中速设备。</li>
<li>数组选择通道：一次只执行一个程序，以实现内存和外设之间的批量数据传送，常用于高速设备。</li>
<li>数组多路通道：同样采取TDM同时执行多个通道程序。</li>
</ul>
</li>
<li><p><strong>通道程序：</strong></p>
<p>通道通过执行<strong>通道程序</strong>和<strong>设备控制器</strong>共同实现对I/O的控制。通道<strong>完成</strong>了通道程序的执行便要产生中断。</p>
</li>
</ul>
<h4 id="5-2-4-I-O系统结构"><a href="#5-2-4-I-O系统结构" class="headerlink" title="5.2.4 I/O系统结构"></a>5.2.4 I/O系统结构</h4><ul>
<li><strong>总线型I/O系统</strong></li>
<li><strong>通道型I/O系统</strong></li>
</ul>
<h3 id="5-3-输入-输出控制方式"><a href="#5-3-输入-输出控制方式" class="headerlink" title="5.3 输入/输出控制方式"></a>5.3 输入/输出控制方式</h3><p>减少CPU对IO的干预，把CPU从IO控制中解放出来，主要分为如下四种控制方式：</p>
<ul>
<li><p>程序直接控制方式</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm2ect9e4xj30mk10en3u.jpg" alt="image-20201227142744117" style="zoom:50%;" />

<p>该方法缺点: CPU和I/O设备只能串行工作，CPU需要一直轮询检查,长期处于“忙等”状态，CPU利用率低。</p>
</li>
<li><p>中断驱动控制方式</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm2ekkdch7j30oy0zin41.jpg" alt="image-20201227143511971" style="zoom:50%;" />

<p>缺点:每个字在I/O设备与内存之间的传输，都需要经过CPU，而频繁的中断处理会消耗较多的CPU时间。</p>
</li>
<li><p>DMA直接存储器存取方式</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm2f29webmj31lx0u0h8r.jpg" alt="image-20201227145213419" style="zoom: 50%;" />

<p>缺点:CPU每发出一条IO指令，只能读/写一个或多个连续的数据块。</p>
</li>
<li><p>通道控制方式</p>
<p>与DMA类似，以<strong>内存</strong>为中心，实现设备与内存直接进行数据交换的控制方式。</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm2f9onapmj31pt0u0kjl.jpg" alt="image-20201227145920053"></p>
<h3 id="5-4-缓冲管理"><a href="#5-4-缓冲管理" class="headerlink" title="5.4 缓冲管理"></a>5.4 缓冲管理</h3><h3 id="5-5-IO软件"><a href="#5-5-IO软件" class="headerlink" title="5.5 IO软件"></a>5.5 IO软件</h3><h3 id="5-7-SPOOLing系统"><a href="#5-7-SPOOLing系统" class="headerlink" title="5.7 SPOOLing系统"></a>5.7 SPOOLing系统</h3><h3 id="第五章练习题"><a href="#第五章练习题" class="headerlink" title="第五章练习题"></a>第五章练习题</h3><ol>
<li><p>大多数低速设备属于（独占设备）。</p>
</li>
<li><p>关于通道、设备控制器和设备之间的关系，以下叙述中正确的是（C）</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glu6ypgnknj30qy060t9o.jpg" alt="image-20201220120728801"></p>
</li>
<li><p>通道用于实现（内存和外设）之间的信息传输。</p>
</li>
<li><p>设备控制器中中用于实现对设备控制功能的是（I/O逻辑）。</p>
</li>
<li><p>为了便于上层软件的编制，设备控制器通常需要提供（A）</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glu71dsu87j30mu0683ze.jpg" alt="image-20201220121001203"></p>
</li>
<li><p>通道执行CPU 指令构成的程序，与设备控制器一起共同实现对 I/O 设备的控制。（❌，通道执行<strong>通道</strong>指令构成的程序，通道本身是一个处理机，指令非常单一，通道没有独立的内存）</p>
</li>
<li><p>在DMA控制方式下，外部设备与CPU直接之间进行成批的数据交换。（❌，设备与主存间的直接交换）</p>
</li>
<li><p>DMA控制方式是在（I/O设备和主存）之间建立一条直接数据通路。</p>
</li>
<li><p>在I/O控制方式的发展过程中，最主要的推动因素是（减少主机对I/O控制的干预）</p>
</li>
<li><p>在中断控制方式下，I/O操作的数据传输必须经过CPU。（✅）</p>
</li>
<li><p>==在关于SPOOLing的叙述中，(D)描述是不正确的。？？？？？？？！！！！！==</p>
<p>A．SPOOLing系统中必须使用独占设备<br>B．SPOOLing系统加快了作业执行的速度<br>C．SPOOLing系统使独占设备“变成”共享设备<br>D．SPOOLing系统利用了处理器与通道并行工作的能力</p>
</li>
<li><p>当作业执行过程中要求读取信息时，SPOOLing系统中的“预输入程序”负责从输入井中为作业读入信息。（❌ “输入井读”负责）</p>
</li>
<li><p>（通道技术）是一种硬件机制。</p>
</li>
<li><p>为了使多个进程能有效地同时处理输入和输出，最好使用（缓冲池）结构的缓冲技术。</p>
</li>
<li><p>如果CPU处理数据的速度与设备输入数据的速度差不多时，比较合理的缓冲机制是（单缓冲）。</p>
</li>
<li><p>如果CPU处理数据的速度远高于设备输入数据的速度时，比较合理的缓冲机制是（缓冲池）。</p>
</li>
<li><p>缓冲技术的缓冲池在（主存）。</p>
</li>
<li><p>用户程序通过（系统调用）向操作系统提出使用外部设备的要求。</p>
</li>
<li><p>与设备相关的中断处理过程是由设备驱动程序完成的。（✅）</p>
</li>
<li><p>逻辑设备到物理设备的映射是在用户层软件中完成的。（❌ 设备独立性软件）</p>
</li>
<li><p>设备独立性软件执行所有设备的公用操作。（✅）</p>
</li>
<li><p>设备的打开、关闭、读、写等操作是由(设备驱动程序)完成的。</p>
</li>
<li><p>来自通道的I/O中断事件由设备管理负责处理。（✅）</p>
</li>
<li><p>所有设备的启动工作都由系统统一来做。（✅）</p>
</li>
<li><p>某文件离散地存储在磁盘的100个块中，系统采用通道I/O控制方式。如果把这个文件的内容全部读入内存，则会中断CPU（1）次。</p>
</li>
<li><p>I/O中断是CPU与通道协调工作的一种手段，所以在（通道完成整个通道程序执行）时，便要产生中断。</p>
</li>
<li><p>在如下几种类型的系统中，（a.b）采用忙等待I/O是合适的。</p>
<p>a.专门用来控制单I/O设备的系统    b.运行一个单任务操作系统的个人计算机    c.作为一个负载很大的网络服务器的工作站</p>
</li>
<li><p>磁盘高速缓冲设在（内存）中，其主要目的是提高磁盘I/O的速度。</p>
</li>
<li><p>提高单机资源利用率的关键技术是(D)。</p>
<p>A．SPOOLing技术    B．虚拟技术    C．交换技术    D．多道程序设计技术</p>
<p>SPOOLing技术用于解决独占设备问题。虚拟技术与交换技术以多道程序设计技术为前提。多道程序设计技术由于同时在主存中运行多个程序，因此提高了系统资源的利用率。</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gme3yy9a3bj312y0pkgpr.jpg" alt="image-20210106173445044"></p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gme449atfsj314q0tytdr.jpg" alt="image-20210106174019429"></p>
<p><a href="https://www.cnblogs.com/zhuhengjie/p/5966888.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuhengjie/p/5966888.html</a></p>
</li>
</ol>
<h2 id="第六章：文件管理"><a href="#第六章：文件管理" class="headerlink" title="第六章：文件管理"></a>第六章：文件管理</h2><h3 id="6-1-文件和文件系统"><a href="#6-1-文件和文件系统" class="headerlink" title="6.1 文件和文件系统"></a>6.1 文件和文件系统</h3><h4 id="6-1-1-文件"><a href="#6-1-1-文件" class="headerlink" title="6.1.1 文件"></a>6.1.1 文件</h4><ul>
<li><p><strong>文件的概念</strong></p>
<p>具有符号名的、在逻辑上有完整意义的一组相关信息项的有序集合。</p>
</li>
<li><p><strong>文件的类型</strong></p>
<ul>
<li>文件用途：系统文件、库文件、用户文件</li>
<li>文件保护级别：只读文件、读写文件、只执行文件和不保护文件</li>
<li>文件存取方法：顺序存取文件和随机存取文件</li>
<li>实际文件分类：普通文件、目录文件（和特殊文件）</li>
</ul>
</li>
</ul>
<h4 id="6-1-2-文件系统"><a href="#6-1-2-文件系统" class="headerlink" title="6.1.2 文件系统"></a>6.1.2 文件系统</h4><p>从用户角度看，文件系统负责为用户完成基本文件操作，实现对文件的按名存取以及实现存取控制。</p>
<p>从系统角度看，文件系统具有如下功能：</p>
<ul>
<li>文件存储空间管理</li>
<li>文件目录管理：文件系统最基本的功能即实现文件的“按名存取”。</li>
<li>文件地址映射</li>
<li>文件读写管理与共享保护</li>
</ul>
<h3 id="6-2-文件的结构和存取"><a href="#6-2-文件的结构和存取" class="headerlink" title="6.2 文件的结构和存取"></a>6.2 文件的结构和存取</h3><h4 id="6-2-1-文件的逻辑结构"><a href="#6-2-1-文件的逻辑结构" class="headerlink" title="6.2.1 文件的逻辑结构"></a>6.2.1 文件的逻辑结构</h4><p>从用户观点出发思考文件内部数据是如何组织起来的，可以分为有结构文件和无结构文件两大类：</p>
<ul>
<li><p><strong>有结构文件：</strong></p>
<p>指文件有若干条记录构成，<strong>记录</strong>是用户程序与文件系统交换信息的<strong>基本单位</strong>，其数据组织形式分为三级：数据项、记录和文件，三者关系逐级包含递增。</p>
<ul>
<li><p>顺序文件：</p>
<p>取决于记录是否定长可分为定长记录顺序文件和变长记录顺序文件。优点是顺序存取时效率高，缺点是不利于文件查找、动态增加或删除。</p>
</li>
<li><p>索引文件：</p>
<p>索引文件为逻辑文件信息建立一张索引表，表项内容存放记录的关键字、长度和起始位置，不再保存记录的长度信息。优点是可以随机访问，便于修改和删除，但是增加存储空间的开销。</p>
</li>
<li><p>索引顺序文件：</p>
<p>将顺序文件中的所有记录分成若干组，为顺序文件建立一张索引表，并为每组中的第一条记录在索引表中建立一个索引项，同样增加了存储空间开销。</p>
</li>
<li><p>直接文件和散列文件</p>
<p>直接文件是建立关键字和相应记录物理地址之间的对应关系；散列(Hash)文件通过散列函数对关键字进行转换来直接决定记录的物理地址。</p>
</li>
</ul>
</li>
<li><p><strong>无结构文件：</strong></p>
<p>内部不再划分记录，而是由一组相关信息组成的有序字符流，亦称为流式文件，长度按字节计算。</p>
</li>
</ul>
<h4 id="6-2-2-文件的物理结构"><a href="#6-2-2-文件的物理结构" class="headerlink" title="6.2.2 文件的物理结构"></a>6.2.2 文件的物理结构</h4><p>从OS观点出发思考文件数据如何存放在外存当中，亦称为文件的存储结构，是文件在<strong>外存</strong>（磁盘）上的存储组织形式，物理块是磁盘上的一组连续扇区，也是<strong>文件分配和传输信息</strong>的基本单位常用的文件物理结构有如下三种：</p>
<ul>
<li><p><strong>连续文件：</strong></p>
<p>把逻辑文件中的信息顺序地存放起来， 优点是顺序存取速度快，缺点是需要有连续的存储空间，容易产生磁盘外部碎片，不利于文件的动态增长。</p>
</li>
<li><p><strong>链接文件：</strong></p>
<ul>
<li><p>隐式链接：</p>
<p>在每个磁盘块最后一个单元中设置一个链接指针，用于指示下一个磁盘块的盘块号，优点是解决了连续文件中的碎片问题，但是只能对文件顺序存取，即读入i号(从0号块算起)逻辑块，需要i+1次磁盘IO。</p>
</li>
<li><p>显式链接：</p>
<p>把链接文件各磁盘块的链接指针显式存放在外存链接表中，一个磁盘对应一张文件分配表FAT，由于FAT常驻内存，所以不需要访问磁盘。</p>
</li>
</ul>
</li>
<li><p><strong>索引文件：</strong></p>
<ul>
<li><p>单级索引文件：</p>
<p>系统为每个文件建立一张索引表，每个逻辑块占一个表项，表项内容为逻辑块所对应的磁盘块号。</p>
</li>
<li><p>多级索引文件：</p>
<p>给单级索引表建立新的一级索引，用于存放索引块的盘块号，同多级页表，最大优点是提供对大文件的支持，但是随着索引级数增多，启动磁盘次数也随之增多。采用K级索引结构，并且K层（顶层）未被调入内存，则访问一个数据块需要K+1次磁盘读操作。</p>
</li>
<li><p>混合索引文件：</p>
<p>采用数组作为地址索引表，前n位为直接地址，存放文件前n+1(0开始算起)个数据块所在磁盘盘块号，第n+1位为一级索引，指向文件的第一个一级索引块，n+2位为二级索引，以此类推。</p>
</li>
</ul>
<p><strong>注意：</strong>文件分配表FAT是一个磁盘对应一张，而索引表是一个文件对应一张</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glnt90g138j31yw0u0npd.jpg" alt="image-20201214233932626"></p>
<h4 id="6-2-3-文件存取"><a href="#6-2-3-文件存取" class="headerlink" title="6.2.3 文件存取"></a>6.2.3 文件存取</h4><table>
<thead>
<tr>
<th>存储介质类型</th>
<th>磁盘</th>
<th>磁盘</th>
<th>磁盘</th>
<th>磁带</th>
</tr>
</thead>
<tbody><tr>
<td>物理结构</td>
<td>连续文件</td>
<td>隐式链接文件</td>
<td>索引文件</td>
<td>连续文件</td>
</tr>
<tr>
<td>存取方法</td>
<td>顺序，随机</td>
<td>顺序</td>
<td>顺序，随机</td>
<td>顺序</td>
</tr>
</tbody></table>
<h3 id="6-3-文件目录管理"><a href="#6-3-文件目录管理" class="headerlink" title="6.3 文件目录管理"></a>6.3 文件目录管理</h3><h4 id="6-3-1-文件目录的概念"><a href="#6-3-1-文件目录的概念" class="headerlink" title="6.3.1 文件目录的概念"></a>6.3.1 文件目录的概念</h4><p>文件目录管理最主要是为了实现文件的“按名存取”，此外还具有提高文件目录检索速度、允许文件重名和共享功能。</p>
<ul>
<li><p><strong>文件控制块（FCB）：</strong></p>
<p>描述和控制文件的数据结构，每个文件都有一个文件控制块，也是文件存在的唯一标识。目录是一组文件控制块的有序集合，即一个文件控制块是一个文件目录项。通常包含三类信息：基本信息、存储控制信息和使用信息。</p>
</li>
<li><p><strong>索引节点：</strong></p>
<p>将FCB中的文件名同其他信息分开，使得除文件名以外的文件描述信息单独形成一个数据结构，称为索引节点，此时文件目录项就由文件名和指向文件i节点的指针组成。根据索引节点的位置，可分为如下两类：</p>
<ul>
<li><p>磁盘索引节点：</p>
<p>存放在磁盘上的索引节点，每个文件都有唯一的一个磁盘索引节点，包含了FCB除文件名外的所有文件属性信息。</p>
</li>
<li><p>内存索引节点：</p>
<p>每当打开一个文件，都会在内存中为该文件建立一个内存索引节点，主要内容是复制磁盘索引节点，并增加一些使用状态信息。</p>
</li>
</ul>
</li>
</ul>
<h4 id="6-3-2-文件目录结构"><a href="#6-3-2-文件目录结构" class="headerlink" title="6.3.2 文件目录结构"></a>6.3.2 文件目录结构</h4><p>文件系统把一组文件的目录项组织成一个独立的文件，全部由文件目录项组成的文件成为目录文件常用的文件目录结构形式有如下三种：</p>
<ul>
<li><p><strong>单级目录结构：</strong></p>
<p>即线性目录表，缺点是查找速度慢、不允许重名和文件共享。</p>
</li>
<li><p><strong>两级目录结构：</strong></p>
<p>将文件目录分为主文件目录(MFD)和用户文件目录(UFD)，系统为每个用户单独建立一个用户文件目录，优点是提高了目录检索速度和文件重名(仅限不同用户之间)，可以用不同的文件名访问系统中同一个共享文件；但是缺乏灵活性和满足文件多的用户的需求。</p>
</li>
<li><p><strong>多级目录结构：</strong></p>
<p>又称为树型目录结构，主文件目录称为根目录，非叶节点均为子目录文件，叶节点为数据文件。目录表述方式分为相对路径和绝对路径两种。</p>
</li>
</ul>
<h4 id="6-3-3-目录检索技术"><a href="#6-3-3-目录检索技术" class="headerlink" title="6.3.3 目录检索技术"></a>6.3.3 目录检索技术</h4><ul>
<li><strong>线性检索法：</strong>按照文件路径名顺序检索匹配对应目录项的文件名。</li>
<li><strong>Hash方法：</strong>通过转换为文件目录的索引值进行查找。</li>
</ul>
<h3 id="6-4-文件存储空间管理"><a href="#6-4-文件存储空间管理" class="headerlink" title="6.4 文件存储空间管理"></a>6.4 文件存储空间管理</h3><h4 id="6-4-1-空闲表法"><a href="#6-4-1-空闲表法" class="headerlink" title="6.4.1 空闲表法"></a>6.4.1 空闲表法</h4><p>文件系统为外存上的所有空闲分区建立一张空闲表，每个空闲区占一个表项，包括序号、该空闲区的起始盘块号以及空闲盘块数等信息，再将所有空闲区按其起始盘块号递增的次序排列。</p>
<ul>
<li><p><strong>优点：</strong></p>
<p>适用于外存空间的连续分配，并且仅当空闲区的数量较少时才有较好的效果</p>
</li>
<li><p><strong>缺点：</strong></p>
<p>有大量空闲区时空闲表会很大</p>
</li>
</ul>
<h4 id="6-4-2-空闲块链表法"><a href="#6-4-2-空闲块链表法" class="headerlink" title="6.4.2 空闲块链表法"></a>6.4.2 空闲块链表法</h4><ul>
<li><strong>空闲盘块链：</strong>磁盘的每一个空闲盘块中存放一个指针，指向另一个空闲盘块，这样磁盘上的所有空闲块链接在一起形成一个链表。</li>
<li><strong>空闲盘区链：</strong>每个空闲盘区包含若干个连续的空闲盘块。</li>
</ul>
<h4 id="6-4-3-位示图（Linux）"><a href="#6-4-3-位示图（Linux）" class="headerlink" title="6.4.3 位示图（Linux）"></a>6.4.3 位示图（Linux）</h4><p>利用一位二进制位来表示磁盘中一个盘块的使用情况。当其值为“0”时，表示对应的盘块空闲；为“1”时，表示已分配。</p>
<p>磁盘上的每个盘块都有一个二进制位与之对应，所有盘块的二进制位构成的集合称为位示图。</p>
<ul>
<li><p><strong>盘块的分配：</strong>i，j，b从1开始计数</p>
<p>顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位(“0”表示空闲时)。将所找到的一个或一组二进制位，转换成与之相应的盘块号。假定找到的其值为“0”的二进制位，位于位示图的第i行、第j列，则其相应的盘块号应按下式计算：<strong>b=n(i-1)+j</strong>,式中n代表每行的位数，i，j，b从1开始计数。修改位示图，令<strong>map[i,j]=1</strong>。</p>
</li>
<li><p><strong>盘块的回收：</strong>i，j，b从1开始计数</p>
<p>将回收盘块的盘块号b转换成位示图中的行号i和列号j，转换公式为：</p>
<p><strong>i=(b-1)DIVn+1</strong></p>
<p><strong>j=(b-1)MODn+1</strong></p>
<p>修改位示图，令map [i,j]=0</p>
</li>
</ul>
<h4 id="6-4-4-成组链接法（Unix）"><a href="#6-4-4-成组链接法（Unix）" class="headerlink" title="6.4.4 成组链接法（Unix）"></a>6.4.4 成组链接法（Unix）</h4><p>先把所有空闲磁盘块按照固定的数量分成若干组，把每组（第一组除外）的<strong>磁盘块总块数</strong>和该组的所有<strong>磁盘块号</strong>记录到前一组的最末磁盘块中，第一组的磁盘块总块数和各磁盘块号记录在空闲盘块栈中，存放在<strong>超级块</strong>里。</p>
<ul>
<li><p><strong>空闲磁盘块的分配：</strong></p>
<p>当系统要为用户分配文件所需的盘块时，须调用盘块分配过程来完成。该过程首先检查空闲盘块号栈是否上锁，如未上锁，便从栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格。若该盘块号已是栈底，即S.free(0)，这是当前栈中最后一个可分配的盘块号。由于在该盘块号所对应的盘块中记有下一组可用的盘块号，因此，须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内容，并把原栈底对应的盘块分配出去(其中的有用数据已读入栈中)。然后，再分配一相应的缓冲区(作为该盘块的缓冲区)。最后，把栈中的空闲盘块数减1 并返回，具体实现伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">count = 当前组空闲盘块数;</span><br><span class="line">S_free--;</span><br><span class="line">b = *S_free;</span><br><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">1</span>)then&#123;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">1</span>)then&#123;</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>)then</span><br><span class="line">    拒绝分配，返回<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    将b中内容读入空闲盘块栈;</span><br><span class="line">    count = 当前组空闲盘块总数;</span><br><span class="line">    S_free = count;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>空闲磁盘块的回收：</strong></p>
<p>在系统回收空闲盘块时，须调用盘块回收过程进行回收。它是将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1 操作。当栈中空闲盘块号数目已达100 时，表示栈已满，便将现有栈中的100个盘块号记入新回收的盘块中，再将其盘块号作为新栈底，伪代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">count = 当前组空闲盘块总数;</span><br><span class="line">b:回收块号;</span><br><span class="line"><span class="keyword">if</span>(count &lt; <span class="number">100</span>)then&#123;</span><br><span class="line">  *S_free = b;</span><br><span class="line">  count++;</span><br><span class="line">  S_free++;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">100</span>)then&#123;</span><br><span class="line">  将空闲盘块栈内容写入b中;</span><br><span class="line">  count = <span class="number">1</span>;</span><br><span class="line">  S_free = <span class="number">0</span>;</span><br><span class="line">  *S_free = b;</span><br><span class="line">  S_free++;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关于成组链接法可以参考：<a href="https://blog.csdn.net/ajay666/article/details/73569654" target="_blank" rel="noopener">https://blog.csdn.net/ajay666/article/details/73569654</a></p>
<h3 id="6-5-文件共享与文件保护"><a href="#6-5-文件共享与文件保护" class="headerlink" title="6.5 文件共享与文件保护"></a>6.5 文件共享与文件保护</h3><h4 id="6-5-1-文件共享"><a href="#6-5-1-文件共享" class="headerlink" title="6.5.1 文件共享"></a>6.5.1 文件共享</h4><p>文件共享是指一个文件可以被多个授权用户使用。实现文件共享的实质就是可以使用不同的路径、不同的文件名打开同一个文件。常用文件共享方法有如下两种，都是在树形结构目录基础上适当修改形成的。</p>
<ol>
<li><p><strong>基于索引节点的共享方式（硬链接）</strong></p>
<p><strong>实现方式：</strong>令文件目录项只包含文件名和指向索引节点的指针，文件的物理地址及其他描述信息保存在索引节点中，然后让两个或者多个不同的目录项只需要指向相同的索引节点即可。</p>
<p>在基于索引节点的共享方式中，可在索引节点中设置一个链接计数字段count，用来表示链接到本索引节点上的用户目录项的数目。当count值为1时，文件主才可以删除该文件，除了文件主，其他用户只能断开与共享文件的链接。</p>
<ul>
<li><p><strong>优点：</strong></p>
<p>可以实现文件异名共享且系统开销不大。</p>
</li>
<li><p><strong>缺点：</strong></p>
<p>有多个用户共享文件时，文件主不能删除文件，且不能实现跨文件卷的共享（因为不同文件卷中的索引节点编号是重复的）。</p>
</li>
</ul>
</li>
<li><p><strong>利用符号链接实现文件共享（软链接）</strong></p>
<p><strong>实现方式：</strong>为共享文件创建一个link类型的新文件分配并填写一个空闲i节点，然后建立目录项，分配磁盘空间，写入文件内容（共享文件的路径名）。</p>
<ul>
<li><p><strong>优点：</strong></p>
<p>不会留下悬空指针，可以实现跨文件卷和网络文件共享。</p>
</li>
<li><p><strong>缺点：</strong></p>
<p>系统开销大，一是检索开销大：访问共享文件时需要进行两次目录检索（查找符号链接文件和共享文件的目录项）；二是存储开销大：必须为符号链接文件配置索引节点并分配一个磁盘块存放共享文件的路径名。</p>
</li>
</ul>
</li>
<li><p><strong>硬链接和符号链接的区别</strong></p>
<ul>
<li>链接计数不一样：符号链接的链接计数不会增加；</li>
<li>文件大小不一样：硬链接文件显示的大小跟原文件一样，因为是同一个文件；符号链接显示的大小与原文件不同。</li>
<li>硬链接不能跨越文件卷建立链接，不能给目录创建硬链接；而符号链接可以。</li>
</ul>
</li>
</ol>
<h4 id="6-5-2-文件保护"><a href="#6-5-2-文件保护" class="headerlink" title="6.5.2 文件保护"></a>6.5.2 文件保护</h4><p>造成文件被破坏的原因：</p>
<ul>
<li><p>系统软硬件错误：系统可靠性</p>
</li>
<li><p>被未授权用户访问：系统安全性</p>
</li>
</ul>
<ol>
<li><p><strong>文件备份</strong></p>
<ul>
<li><p><strong>批量备份</strong></p>
<ul>
<li><p>全量转储：</p>
<p>周期性转储或者定期备份，即把文件存储器中的全部文件定期复制到后援存储器中，当系统出现故障、文件遭到破坏时，便可把最后一次转储内容从后援存储器复制回系统以恢复正常运行。</p>
</li>
<li><p>增量转储：</p>
<p>每隔一段时间便把上次转储以来修改过的文件和新建立的文件转储到后援存储器中。</p>
</li>
</ul>
</li>
<li><p><strong>同步备份</strong></p>
<ul>
<li><p>镜像盘支持：完全相同的镜像盘。</p>
</li>
<li><p>双机动态文件备份：两台机器。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>文件访问保护</strong></p>
<ul>
<li><p><strong>口令保护</strong></p>
</li>
<li><p><strong>加密保护</strong></p>
</li>
<li><p><strong>设置文件使用权限</strong></p>
<p>把每个文件的用户分成三类：文件主、伙伴用户(同组用户)和一般用户，对每一类用户分别规定使用文件的权限，然后将这些使用权限作为文件的存取控制信息保存在文件控制块或索引节点中。当用户要求访问某个文件时，系统首先检查该用户类型，然后再按存取权限的规定核用户的使用要求，仅当权限符合时才允许访问该文件。</p>
<ul>
<li>访问控制矩阵</li>
<li>访问控制表</li>
<li>用户权限表</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="6-6-磁盘调度"><a href="#6-6-磁盘调度" class="headerlink" title="6.6 磁盘调度"></a>6.6 磁盘调度</h3><h4 id="6-6-1-磁盘管理概述"><a href="#6-6-1-磁盘管理概述" class="headerlink" title="6.6.1 磁盘管理概述"></a>6.6.1 磁盘管理概述</h4><ul>
<li><p><strong>磁盘相关概念：</strong></p>
<ul>
<li><p>磁盘、磁道、扇区（磁盘上盘面被划分成一个个磁道、一个磁道被划分成若干个扇区，每个扇区就是一个磁盘块，各个扇区存放的数据量相同，因此最内侧扇区面积最小，数据密度最大）</p>
</li>
<li><p>盘面、柱面：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu3x224qgj313l0u0npd.jpg" alt="image-20201220102156653"></p>
</li>
</ul>
</li>
<li><p><strong>数据的组织和格式：</strong></p>
<ul>
<li>CHS</li>
<li>LBA</li>
</ul>
</li>
<li><p><strong>磁盘访问时间：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu4ad6bhuj312k0u0e2g.jpg" alt="image-20201220103444063"></p>
<p>其中<strong>延迟时间</strong>和<strong>传输时间</strong>和<strong>磁盘转速</strong>线性相关，是磁盘的固有属性，操作系统无法直接影响，只有寻道时间可以根据不同的调度算法来产生影响。</p>
</li>
</ul>
<h4 id="6-6-2-磁盘调度算法"><a href="#6-6-2-磁盘调度算法" class="headerlink" title="6.6.2 磁盘调度算法"></a>6.6.2 磁盘调度算法</h4><ul>
<li><p><strong>移臂调度：</strong></p>
<ul>
<li><p>FCFS先来先服务算法：</p>
<p>按照访问磁盘先后次序进行调度，不会产生饥饿现象，但寻道时间可能比较长。</p>
</li>
<li><p>SSTF最短寻道时间优先算法：</p>
<p>选择当前磁道距离最近的磁道访问请求，会产生饥饿现象，也可能会导致磁头频繁移动影响磁盘寿命。</p>
</li>
<li><p>SCAN扫描算法：</p>
<p>从当前磁头移动方向顺序访问，选择与当前磁道距离最近的磁道访问请求，如无访问请求，改变磁头方向逆向选择。</p>
</li>
<li><p>CSCAN循环扫描算法：</p>
<p>在上述基础上规定磁头单向移动，当磁头完成最内层访问请求后重新回到最外层。</p>
</li>
<li><p>N-Step-SCAN算法：</p>
<p>将当前磁盘请求队列分为若干长度为N的子队列，按FCFS处理子队列，对于子队列内部采取SCAN算法，该算法可能会产生磁臂粘着现象，即同一柱面不断有访问请求。</p>
</li>
<li><p>FSCAN算法：</p>
<p>对上述算法简化，只分为两个子队列，当前所有访问请求组织为一个队列，按SCAN处理，对新出现的IO请求放入另一个待处理的请求队列，等上一个队列处理完成后再处理这个。</p>
</li>
</ul>
</li>
<li><p><strong>旋转调度：</strong></p>
<p>当一条磁道上有多个扇区访问请求时，确定扇区访问顺序，总是选择与当前读写头最近的那个IO请求，使得旋转圈数最少。</p>
</li>
</ul>
<h3 id="6-7-Linux文件系统"><a href="#6-7-Linux文件系统" class="headerlink" title="6.7 Linux文件系统"></a>6.7 Linux文件系统</h3><h4 id="6-7-1-Linux文件属性"><a href="#6-7-1-Linux文件属性" class="headerlink" title="6.7.1 Linux文件属性"></a>6.7.1 Linux文件属性</h4><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>
<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>
<ul>
<li>chown (change ownerp) ： 修改所属用户与组。</li>
<li>chmod (change mode) ： 修改用户的权限。</li>
</ul>
<p>下图中通过 chown 来授权用户，通过 chmod 为用户设置可以开门的权限。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/1_151733904241.png" alt="img"></p>
<p>在 Linux 中我们可以使用 <strong>ll</strong> 或者 <strong>ls –l</strong> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www &#x2F;]# ls -l</span><br><span class="line">total 64</span><br><span class="line">dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</span><br><span class="line">dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>实例中，<strong>bin</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul>
<li>当为 <strong>d</strong> 则是目录</li>
<li>当为 <strong>-</strong> 则是文件</li>
<li>若是 <strong>l</strong> 则表示为链接文档(link file)</li>
<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)，块设备文件</li>
<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)，字符设备文件</li>
<li>若是 <strong>s</strong> 则表示为socket文件</li>
<li>若是 <strong>p</strong> 则表示为管道文件</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/file-llls22.jpg" alt="img"></p>
<p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p>
<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>
<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p>
<p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p>
<p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>
<h3 id="第六章练习题"><a href="#第六章练习题" class="headerlink" title="第六章练习题"></a>第六章练习题</h3><ol>
<li><p>在文件系统中，文件的不同物理结构有不同的优缺点。在下列文件的物理结构中(B)结构不具有直接读写文件任意一个记录的能力。</p>
<p>A．顺序结构<br>B．链接结构<br>C．索引结构<br>D．Hash结构</p>
<p>顺序结构把逻辑文件的记录顺序地存放在连续的物理盘块中，可以直接对指定物理盘块的访问：对于链接结构，文件的各个记录可以存放在不相邻的物理盘块中，通过物理盘块中的链接指针链接成一个链表，对链表中元素的访问需要从头指针开始，不能直接访问；索引文件为每个文件建立一张索引表实现记录和物理块之间的映射，通过查找索引表实现对文件的直接存取。Hash结构通过计算(杂凑函数)来确定一个记录在存储设备上的具体存储位置实现直接访问。</p>
</li>
<li><p>文件的存储空间管理实质上是对（外存空闲区）的组织和管理。</p>
</li>
<li><p>位示图可用于磁盘空间的管理。设某系统磁盘共有500块，块号为0～499，<strong>第0行的第0位表示第0块</strong>，第0行的第1位表示第1块，依次类推。若用位示图管理者500块的磁盘空间，当字长为32位时，第i个字节第j位对应的块号是（32i+j）。</p>
</li>
<li><p>有8个字长（假设字长为32位）组成的位示图管理磁盘空间，用户归还一个块号为100的盘块时，它对应的位示图的位置为（i=j=4）。（行、列号及盘块号都从1开始）</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gks4zq4lohj314u0rqaf6.jpg" alt="image-20201117140739856"></p>
<p>因为物理块编号是从0开始的，所以4195号物理块其实就是第4196块。因为字长为32位，也就是说，每个字可以记录32个物理块的使用情况。4196/32=131.125，所以，4195号物理块应该在第131个字中（字的编号也是从0开始计数）。那么，具体在第131个字的哪一位呢？到第130个字为止，共保存了131*32=4192个物理块（0～4191），所以，第4195块应该在第131个字的第3位记录（要注意：0是最开始的位）。因为系统已经将4195号物理块分配给某文件，所以其对应的位要置1。</p>
</li>
<li><p>设某系统的磁盘空间共有10000个盘块，系统中每字的字长为32位，则相应的位示图需要（313）个字来构造（10000/32）。</p>
</li>
<li><p>若采用口令保护方式来保护文件，则“口令”最合适的保存位置是（文件控制块或索引节点）。</p>
</li>
<li><p>Linux的ext2文件系统采用用户权限表实现文件保护（❌  Unix和Linux都使用访问控制表）。</p>
</li>
<li><p>基于索引节点的共享方式，不能用于目录文件的共享（✅）。</p>
</li>
<li><p>利用符号链接实现文件共享时，系统开销会增加，因为需要真实地创建一个新文件（✅）。</p>
</li>
<li><p>Linux执行下述命令后，请计算各文件的i节点count计数值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">touch</span> /<span class="selector-tag">tmp</span>/<span class="selector-tag">foo</span>  #创建<span class="selector-tag">foo</span>文件</span><br><span class="line"><span class="selector-tag">mkdir</span> /<span class="selector-tag">tmp</span>/<span class="selector-tag">bar</span>  #创建<span class="selector-tag">bar</span>文件夹</span><br><span class="line"><span class="selector-tag">mkdir</span> /<span class="selector-tag">tmp</span>/<span class="selector-tag">bar</span>/<span class="selector-tag">gag</span>  #创建<span class="selector-tag">gag</span>文件夹</span><br><span class="line">ln /tmp/foo /tmp/bar/foo2        #硬链接：使得bar/foo2文件链接至../foo文件  foo文件和foo2文件count=2</span><br><span class="line">ln -s /tmp/foo /tmp/bar/foo      #软链接：使得bar/foo文件链接至../foo文件   bar/foo文件count=1</span><br><span class="line">ln /tmp/foo /tmp/bar/gag/bar     #硬链接：使得bar/gag/bar文件链接至../foo文件  foo文件count=3=bar/gag/bar</span><br><span class="line">ln -s /tmp/bar /tmp/bar/gag/bar2 #软链接：使得bar/gag/bar2文件链接至tmp/bar文件夹 bar/gag/bar2文件=1</span><br><span class="line">ln -s /tmp /tmp/bar/gag/tmp      #软链接：使得bar/gag/tmp文件链接至tmp文件夹 /bar/gag/tmp文件=1</span><br><span class="line"></span><br><span class="line">整体文件树可以表示为：</span><br><span class="line"><span class="selector-tag">tmp</span></span><br><span class="line"><span class="selector-tag">--foo</span><span class="selector-pseudo">:file</span></span><br><span class="line"><span class="selector-tag">--bar</span><span class="selector-pseudo">:dir</span></span><br><span class="line">  <span class="selector-tag">--foo2</span><span class="selector-pseudo">:file(hardfile</span> <span class="selector-tag">to</span> /<span class="selector-tag">tmp</span>/<span class="selector-tag">foo</span>)</span><br><span class="line">  <span class="selector-tag">--foo</span><span class="selector-pseudo">:file(softfile</span> <span class="selector-tag">to</span> /<span class="selector-tag">tmp</span>/<span class="selector-tag">foo</span>)</span><br><span class="line">  <span class="selector-tag">--gag</span><span class="selector-pseudo">:dir</span></span><br><span class="line">  	<span class="selector-tag">--bar</span><span class="selector-pseudo">:file(hardfile</span> <span class="selector-tag">to</span> /<span class="selector-tag">tmp</span>/<span class="selector-tag">foo</span>)</span><br><span class="line">  	<span class="selector-tag">--bar2</span><span class="selector-pseudo">:file(softfile</span> <span class="selector-tag">to</span> /<span class="selector-tag">tmp</span>/<span class="selector-tag">bar</span>)</span><br><span class="line">  	<span class="selector-tag">--tmp</span><span class="selector-pseudo">:file(softfile</span> <span class="selector-tag">to</span> /<span class="selector-tag">tmp</span>)</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line">tmp/foo文件count = 3</span><br><span class="line">tmp/bar/foo2文件count = 2+1（同步增长）</span><br><span class="line">tmp/bar/gag/bar文件count = 3</span><br><span class="line">tmp/bar/foo文件count = 1</span><br><span class="line">tmp/bar/gag/bar2文件count = 1</span><br><span class="line">tmp/bar/gag/tmp文件count = 1</span><br></pre></td></tr></table></figure>

<p>注：ln -s表示软链接，ln表示硬链接；同时硬链接会使得本身count值+1，软链接会新建一条l开头的文件信息，但不会改变本身count值，如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkseqm32sdj30qq06gtc6.jpg" alt="image-20201117194457853"></p>
</li>
<li><p>设文件F1的当前引用计数值为1，先建立文件F1的符号链接文件F2，再建立文件F1的硬链接文件F3，然后删除文件F1，此时，文件F2和文件F3的引用计数值分别是（1，1）。</p>
<p>当建立F2时，F1和F2的引用计数值都为1.当再建立F3时，F1和F3的引用计数值就都变成了2，当后来删除F1时，F3的引用计数值为2-1=1，F2的引用计数值不变。</p>
</li>
<li><p>从文件的管理上分，设置用户对文件的访问控制应属于（用户级管理）。</p>
</li>
<li><p>若用户仅允许他的某些同事访问他的文件，适用哪种文件保护机制（访问控制表）。</p>
</li>
<li><p>启动磁盘读写一块数据时，(传输时间)是硬件设计时就固定的。</p>
</li>
<li><p>某软磁盘有40个磁道，磁头从一个磁道移动到另一个磁道需要6ms。文件在磁盘上非连续存放，逻辑上相邻的数据块的平均距离为13条磁道，每块的旋转延迟时间及传输时间分别为100ms、25ms，则读取一个100块的文件需要的时间是（20300）ms。</p>
<p>对于一个块，寻道时间=13*6=78ms，旋转延迟时间=100ms，传输时间=25ms，足额读取一个块的时间=78+100+25=203</p>
</li>
<li><p>一个磁盘的转速为7200转/分，每个磁道有160个扇区，每扇区有512B，那么理想情况下，其数据传输率为（9600）KB/s。</p>
<p>磁盘转速为7200转/分=120转/s，转一圈160个扇区，每个扇区512B，所以数据传输率=120*160*512/1024=9600KB/s</p>
</li>
<li><p>某磁盘组的每个盘面上有200个磁道，格式化时每个磁道被分成4个扇区，整个磁盘组共有8000个扇区，那么该磁盘组应由（5）盘片组成。（盘片包含正反两方面）</p>
</li>
<li><p>磁盘调度算法中，（FIFO和SSTF）算法可能会随时改变磁头臂的运动方向。</p>
</li>
<li><p>![image-20201215150710317](/Users/paragon/Library/Application Support/typora-user-images/image-20201215150710317.png)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
